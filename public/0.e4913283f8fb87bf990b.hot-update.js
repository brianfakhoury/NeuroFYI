webpackHotUpdate(0,{

/***/ 360:
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./frontend/components/play/Landscape.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ 2);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _three = __webpack_require__(/*! three */ 197);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Landscape = function (_React$Component) {\n    _inherits(Landscape, _React$Component);\n\n    function Landscape(props) {\n        _classCallCheck(this, Landscape);\n\n        return _possibleConstructorReturn(this, (Landscape.__proto__ || Object.getPrototypeOf(Landscape)).call(this, props));\n    }\n\n    _createClass(Landscape, [{\n        key: 'componentWillMount',\n        value: function componentWillMount() {\n            createLandscape();\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            console.log('cancelled');\n            window.cancelAnimationFrame(window.animFrame);\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('canvas', { id: 'canvas3' });\n        }\n    }]);\n\n    return Landscape;\n}(_react2.default.Component);\n\nexports.default = Landscape;\n\n\nfunction createLandscape() {\n    setTimeout(function () {\n        var SimplexNoise = function SimplexNoise(r) {\n            if (r == undefined) r = Math;\n            this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];\n\n            this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];\n\n            this.p = [];\n            for (var i = 0; i < 256; i++) {\n                this.p[i] = Math.floor(r.random() * 256);\n            }\n            // To remove the need for index wrapping, double the permutation table length\n            this.perm = [];\n            for (var i = 0; i < 512; i++) {\n                this.perm[i] = this.p[i & 255];\n            }\n\n            // A lookup table to traverse the simplex around a given point in 4D.\n            // Details can be found where this table is used, in the 4D noise method.\n            this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];\n        };\n\n        SimplexNoise.prototype.dot = function (g, x, y) {\n            return g[0] * x + g[1] * y;\n        };\n\n        SimplexNoise.prototype.dot3 = function (g, x, y, z) {\n            return g[0] * x + g[1] * y + g[2] * z;\n        };\n\n        SimplexNoise.prototype.dot4 = function (g, x, y, z, w) {\n            return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n        };\n\n        SimplexNoise.prototype.noise = function (xin, yin) {\n            var n0, n1, n2; // Noise contributions from the three corners\n            // Skew the input space to determine which simplex cell we're in\n            var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\n            var s = (xin + yin) * F2; // Hairy factor for 2D\n            var i = Math.floor(xin + s);\n            var j = Math.floor(yin + s);\n            var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\n            var t = (i + j) * G2;\n            var X0 = i - t; // Unskew the cell origin back to (x,y) space\n            var Y0 = j - t;\n            var x0 = xin - X0; // The x,y distances from the cell origin\n            var y0 = yin - Y0;\n            // For the 2D case, the simplex shape is an equilateral triangle.\n            // Determine which simplex we are in.\n            var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n            if (x0 > y0) {\n                i1 = 1;\n                j1 = 0;\n            } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n            else {\n                    i1 = 0;\n                    j1 = 1;\n                } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n            // c = (3-sqrt(3))/6\n            var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n            var y1 = y0 - j1 + G2;\n            var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n            var y2 = y0 - 1.0 + 2.0 * G2;\n            // Work out the hashed gradient indices of the three simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var gi0 = this.perm[ii + this.perm[jj]] % 12;\n            var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;\n            var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;\n            // Calculate the contribution from the three corners\n            var t0 = 0.5 - x0 * x0 - y0 * y0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n            }\n            var t1 = 0.5 - x1 * x1 - y1 * y1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n            }\n            var t2 = 0.5 - x2 * x2 - y2 * y2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n            }\n            // Add contributions from each corner to get the final noise value.\n            // The result is scaled to return values in the interval [-1,1].\n            return 70.0 * (n0 + n1 + n2);\n        };\n\n        // 3D simplex noise\n        SimplexNoise.prototype.noise3d = function (xin, yin, zin) {\n            var n0, n1, n2, n3; // Noise contributions from the four corners\n            // Skew the input space to determine which simplex cell we're in\n            var F3 = 1.0 / 3.0;\n            var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\n            var i = Math.floor(xin + s);\n            var j = Math.floor(yin + s);\n            var k = Math.floor(zin + s);\n            var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n            var t = (i + j + k) * G3;\n            var X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n            var Y0 = j - t;\n            var Z0 = k - t;\n            var x0 = xin - X0; // The x,y,z distances from the cell origin\n            var y0 = yin - Y0;\n            var z0 = zin - Z0;\n            // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n            // Determine which simplex we are in.\n            var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n            var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n            if (x0 >= y0) {\n                if (y0 >= z0) {\n                    i1 = 1;\n                    j1 = 0;\n                    k1 = 0;\n                    i2 = 1;\n                    j2 = 1;\n                    k2 = 0;\n                } // X Y Z order\n                else if (x0 >= z0) {\n                        i1 = 1;\n                        j1 = 0;\n                        k1 = 0;\n                        i2 = 1;\n                        j2 = 0;\n                        k2 = 1;\n                    } // X Z Y order\n                    else {\n                            i1 = 0;\n                            j1 = 0;\n                            k1 = 1;\n                            i2 = 1;\n                            j2 = 0;\n                            k2 = 1;\n                        } // Z X Y order\n            } else {\n                // x0<y0\n                if (y0 < z0) {\n                    i1 = 0;\n                    j1 = 0;\n                    k1 = 1;\n                    i2 = 0;\n                    j2 = 1;\n                    k2 = 1;\n                } // Z Y X order\n                else if (x0 < z0) {\n                        i1 = 0;\n                        j1 = 1;\n                        k1 = 0;\n                        i2 = 0;\n                        j2 = 1;\n                        k2 = 1;\n                    } // Y Z X order\n                    else {\n                            i1 = 0;\n                            j1 = 1;\n                            k1 = 0;\n                            i2 = 1;\n                            j2 = 1;\n                            k2 = 0;\n                        } // Y X Z order\n            }\n            // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n            // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n            // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n            // c = 1/6.\n            var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n            var y1 = y0 - j1 + G3;\n            var z1 = z0 - k1 + G3;\n            var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n            var y2 = y0 - j2 + 2.0 * G3;\n            var z2 = z0 - k2 + 2.0 * G3;\n            var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n            var y3 = y0 - 1.0 + 3.0 * G3;\n            var z3 = z0 - 1.0 + 3.0 * G3;\n            // Work out the hashed gradient indices of the four simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var kk = k & 255;\n            var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\n            var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\n            var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\n            var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;\n            // Calculate the contribution from the four corners\n            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n            }\n            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n            }\n            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n            }\n            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n            if (t3 < 0) n3 = 0.0;else {\n                t3 *= t3;\n                n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n            }\n            // Add contributions from each corner to get the final noise value.\n            // The result is scaled to stay just inside [-1,1]\n            return 32.0 * (n0 + n1 + n2 + n3);\n        };\n\n        // 4D simplex noise\n        SimplexNoise.prototype.noise4d = function (x, y, z, w) {\n            // For faster and easier lookups\n            var grad4 = this.grad4;\n            var simplex = this.simplex;\n            var perm = this.perm;\n\n            // The skewing and unskewing factors are hairy again for the 4D case\n            var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\n            var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n            var n0, n1, n2, n3, n4; // Noise contributions from the five corners\n            // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n            var s = (x + y + z + w) * F4; // Factor for 4D skewing\n            var i = Math.floor(x + s);\n            var j = Math.floor(y + s);\n            var k = Math.floor(z + s);\n            var l = Math.floor(w + s);\n            var t = (i + j + k + l) * G4; // Factor for 4D unskewing\n            var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n            var Y0 = j - t;\n            var Z0 = k - t;\n            var W0 = l - t;\n            var x0 = x - X0; // The x,y,z,w distances from the cell origin\n            var y0 = y - Y0;\n            var z0 = z - Z0;\n            var w0 = w - W0;\n\n            // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n            // To find out which of the 24 possible simplices we're in, we need to\n            // determine the magnitude ordering of x0, y0, z0 and w0.\n            // The method below is a good way of finding the ordering of x,y,z,w and\n            // then find the correct traversal order for the simplex we’re in.\n            // First, six pair-wise comparisons are performed between each possible pair\n            // of the four coordinates, and the results are used to add up binary bits\n            // for an integer index.\n            var c1 = x0 > y0 ? 32 : 0;\n            var c2 = x0 > z0 ? 16 : 0;\n            var c3 = y0 > z0 ? 8 : 0;\n            var c4 = x0 > w0 ? 4 : 0;\n            var c5 = y0 > w0 ? 2 : 0;\n            var c6 = z0 > w0 ? 1 : 0;\n            var c = c1 + c2 + c3 + c4 + c5 + c6;\n            var i1, j1, k1, l1; // The integer offsets for the second simplex corner\n            var i2, j2, k2, l2; // The integer offsets for the third simplex corner\n            var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n            // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n            // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n            // impossible. Only the 24 indices which have non-zero entries make any sense.\n            // We use a thresholding to set the coordinates in turn from the largest magnitude.\n            // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n            i1 = simplex[c][0] >= 3 ? 1 : 0;\n            j1 = simplex[c][1] >= 3 ? 1 : 0;\n            k1 = simplex[c][2] >= 3 ? 1 : 0;\n            l1 = simplex[c][3] >= 3 ? 1 : 0;\n            // The number 2 in the \"simplex\" array is at the second largest coordinate.\n            i2 = simplex[c][0] >= 2 ? 1 : 0;\n            j2 = simplex[c][1] >= 2 ? 1 : 0;\n            k2 = simplex[c][2] >= 2 ? 1 : 0;\n            l2 = simplex[c][3] >= 2 ? 1 : 0;\n            // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n            i3 = simplex[c][0] >= 1 ? 1 : 0;\n            j3 = simplex[c][1] >= 1 ? 1 : 0;\n            k3 = simplex[c][2] >= 1 ? 1 : 0;\n            l3 = simplex[c][3] >= 1 ? 1 : 0;\n            // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n            var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n            var y1 = y0 - j1 + G4;\n            var z1 = z0 - k1 + G4;\n            var w1 = w0 - l1 + G4;\n            var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n            var y2 = y0 - j2 + 2.0 * G4;\n            var z2 = z0 - k2 + 2.0 * G4;\n            var w2 = w0 - l2 + 2.0 * G4;\n            var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n            var y3 = y0 - j3 + 3.0 * G4;\n            var z3 = z0 - k3 + 3.0 * G4;\n            var w3 = w0 - l3 + 3.0 * G4;\n            var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n            var y4 = y0 - 1.0 + 4.0 * G4;\n            var z4 = z0 - 1.0 + 4.0 * G4;\n            var w4 = w0 - 1.0 + 4.0 * G4;\n            // Work out the hashed gradient indices of the five simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var kk = k & 255;\n            var ll = l & 255;\n            var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\n            var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\n            var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\n            var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\n            var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\n            // Calculate the contribution from the five corners\n            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\n            }\n            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\n            }\n            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\n            }\n            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n            if (t3 < 0) n3 = 0.0;else {\n                t3 *= t3;\n                n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\n            }\n            var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n            if (t4 < 0) n4 = 0.0;else {\n                t4 *= t4;\n                n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\n            }\n            // Sum up and scale the result to cover the range [-1,1]\n            return 27.0 * (n0 + n1 + n2 + n3 + n4);\n        };\n\n        var THREEx = THREEx || {};\n\n        THREEx.Terrain = {};\n\n        /**\n         * allocate the heightmap\n         *\n         * @param  {Number} width the width of the heightmap\n         * @param  {Number} depth the depth of the heightmap\n         * @return {Array} the allocated heightmap\n         */\n        THREEx.Terrain.allocateHeightMap = function (width, depth) {\n            var ArrayClass = THREEx.Terrain.allocateHeightMap.ArrayClass;\n            var heightMap = new Array(width);\n            for (var x = 0; x < width; x++) {\n                heightMap[x] = new ArrayClass(depth);\n            }\n            return heightMap;\n        };\n        THREEx.Terrain.allocateHeightMap.ArrayClass = window.Float64Array || window.Array;\n\n        /**\n         * generate a heightmap using a simplex noise\n         * @todo make it it tunable... how ?\n         *\n         * @param  {Array} heightMap the heightmap to store the data\n         */\n        THREEx.Terrain.simplexHeightMap = function (heightMap) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            var simplex = new SimplexNoise();\n            for (var x = 0; x < width; x++) {\n                for (var z = 0; z < depth; z++) {\n                    // compute the height\n                    var height = 0;\n                    var level = 8;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.125;\n                    level *= 3;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.25;\n                    level *= 2;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.5;\n                    level *= 2;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 1;\n                    height /= 1 + 0.5 + 0.25 + 0.125;\n                    // put the height in the heightMap\n                    heightMap[x][z] = height;\n                }\n            }\n        };\n\n        /**\n         * build a canvas 2d from a heightmap\n         * @param  {Array} heightMap heightmap\n         * @param  {HTMLCanvasElement|undefined} canvas  the destination canvas.\n         * @return {HTMLCanvasElement}           the canvas\n         */\n        THREEx.Terrain.heightMapToCanvas = function (heightMap, canvas) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // create canvas\n            canvas = canvas || document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = depth;\n            var context = canvas.getContext(\"2d\");\n            // loop on each pixel of the canvas\n            for (var x = 0; x < canvas.width; x++) {\n                for (var y = 0; y < canvas.height; y++) {\n                    var height = heightMap[x][y];\n                    var color = THREEx.Terrain.heightToColor(height);\n                    context.fillStyle = color.getStyle();\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n            // return the just built canvas\n            return canvas;\n        };\n\n        /**\n         * Build a THREE.PlaneGeometry based on a heightMap\n         *\n         * @param  {Array} heightMap the heightmap\n         * @return {THREE.Geometry}  the just built geometry\n         */\n        THREEx.Terrain.heightMapToPlaneGeometry = function (heightMap) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // build geometry\n            var geometry = new THREEx.Terrain.PlaneGeometry(1, 1, width - 1, depth - 1);\n            // loop on each vertex of the geometry\n            for (var x = 0; x < width; x++) {\n                for (var z = 0; z < depth; z++) {\n                    // get the height from heightMap\n                    var height = heightMap[x][z];\n                    // set the vertex.z to a normalized height\n                    var vertex = geometry.vertices[x + z * width];\n                    vertex.z = (height - 0.5) * 2;\n                }\n            }\n            // notify the geometry need to update vertices\n            geometry.verticesNeedUpdate = true;\n            // notify the geometry need to update normals\n            geometry.computeFaceNormals();\n            geometry.computeVertexNormals();\n            geometry.normalsNeedUpdate = true;\n            // return the just built geometry\n            return geometry;\n        };\n\n        THREEx.Terrain.heightMapToHeight = function (heightMap, x, z) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // sanity check - boundaries\n            console.assert(x >= 0 && x < width);\n            console.assert(z >= 0 && z < depth);\n\n            // get the delta within a single segment\n            var deltaX = x - Math.floor(x);\n            var deltaZ = z - Math.floor(z);\n\n            // get the height of each corner of the segment\n            var heightNW = heightMap[Math.floor(x)][Math.floor(z)];\n            var heightNE = heightMap[Math.ceil(x)][Math.floor(z)];\n            var heightSW = heightMap[Math.floor(x)][Math.ceil(z)];\n            var heightSE = heightMap[Math.ceil(x)][Math.ceil(z)];\n\n            // test in which triangle the point is. north-east or south-west\n            var inTriangleNE = deltaX > deltaZ ? true : false;\n            if (inTriangleNE) {\n                var height = heightNE + (heightNW - heightNE) * (1 - deltaX) + (heightSE - heightNE) * deltaZ;\n            } else {\n                var height = heightSW + (heightSE - heightSW) * deltaX + (heightNW - heightSW) * (1 - deltaZ);\n            }\n            // return the height\n            return height;\n        };\n\n        THREEx.Terrain.planeToHeightMapCoords = function (heightMap, planeMesh, x, z) {\n\n            // TODO assert no rotation in planeMesh\n            // - how can i check that ? with euler ?\n\n            var position = new THREE.Vector3(x, 0, z);\n\n            // set position relative to planeMesh position\n            position.sub(planeMesh.position);\n\n            // heightMap origin is at its top-left, while planeMesh origin is at its center\n            position.x += planeMesh.geometry.width / 2 * planeMesh.scale.x;\n            position.z += planeMesh.geometry.height / 2 * planeMesh.scale.y;\n\n            // normalize it from [0,1] for the heightmap\n            position.x /= planeMesh.geometry.width * planeMesh.scale.x;\n            position.z /= planeMesh.geometry.height * planeMesh.scale.y;\n\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            // convert it in heightMap coordinate\n            position.x *= width - 1;\n            position.z *= depth - 1;\n\n            position.y = THREEx.Terrain.heightMapToHeight(heightMap, position.x, position.z);\n            position.y = (position.y - 0.5) * 2;\n            position.y *= planeMesh.scale.z;\n\n            return position.y;\n        };\n\n        THREEx.Terrain.planeToHeightMapCoords0 = function (position, heightMap, planeMesh) {\n\n            // TODO assert no rotation in planeMesh\n            // - how can i check that ? with euler ?\n\n            // set position relative to planeMesh position\n            position.sub(planeMesh.position);\n\n            // heightMap origin is at its top-left, while planeMesh origin is at its center\n            position.x += planeMesh.geometry.width / 2;\n            position.z += planeMesh.geometry.height / 2;\n\n            // normalize it from [0,1] for the heightmap\n            position.x /= planeMesh.geometry.width;\n            position.z /= planeMesh.geometry.height;\n\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            // convert it in heightMap coordinate\n            position.x *= width - 1;\n            position.z *= depth - 1;\n\n            var height = THREEx.Terrain.heightMapToHeight(heightMap, position.x, position.z);\n            position.y = (height - 0.5) * 2;\n\n            return position;\n        };\n\n        /**\n         * Set the vertex color for a THREE.Geometry based on a heightMap\n         *\n         * @param  {Array} heightMap the heightmap\n         * @param  {THREE.Geometry} geometry  the geometry to set\n         */\n        THREEx.Terrain.heightMapToVertexColor = function (heightMap, geometry) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // loop on each vertex of the geometry\n            var color = new THREE.Color();\n            for (var i = 0; i < geometry.faces.length; i++) {\n                var face = geometry.faces[i];\n                if (face instanceof THREE.Face4) {\n                    console.assert(face instanceof THREE.Face4);\n                    face.vertexColors.push(vertexIdxToColor(face.a).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.b).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.c).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.d).clone());\n                } else if (face instanceof THREE.Face3) {\n                    console.assert(face instanceof THREE.Face3);\n                    face.vertexColors.push(vertexIdxToColor(face.a).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.b).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.c).clone());\n                } else console.assert(false);\n            }\n            geometry.colorsNeedUpdate = true;\n            return;\n\n            function vertexIdxToColor(vertexIdx) {\n                var x = Math.floor(vertexIdx % width);\n                var z = Math.floor(vertexIdx / width);\n                var height = heightMap[x][z];\n                return THREEx.Terrain.heightToColor(height);\n            }\n        };\n\n        /**\n         * give a color based on a given height\n         *\n         * @param {Number} height the height\n         * @return {THREE.Color} the color for this height\n         */\n        THREEx.Terrain.heightToColor = function () {\n            var color = new THREE.Color();\n            return function (height) {\n                // compute color based on height\n                if (height < 0.5) {\n                    height = height * 2 * 0.5 + 0.2;\n                    color.setRGB(0, 0, height);\n                } else if (height < 0.7) {\n                    height = (height - 0.5) / 0.2;\n                    height = height * 0.5 + 0.2;\n                    color.setRGB(0, height, 0);\n                } else {\n                    height = (height - 0.7) / 0.3;\n                    height = height * 0.5 + 0.5;\n                    color.setRGB(height, height, height);\n                }\n                // color.setRGB(1,1,1)\n                return color;\n            };\n        }();\n\n        //////////////////////////////////////////////////////////////////////////////////\n        //\t\tcomment\t\t\t\t\t\t\t\t//\n        //////////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * plane geometry with THREE.Face3 from three.js r66\n         *\n         * @param {[type]} width          [description]\n         * @param {[type]} height         [description]\n         * @param {[type]} widthSegments  [description]\n         * @param {[type]} heightSegments [description]\n         */\n        THREEx.Terrain.PlaneGeometry = function (width, height, widthSegments, heightSegments) {\n\n            THREE.Geometry.call(this);\n\n            this.width = width;\n            this.height = height;\n\n            this.widthSegments = widthSegments || 1;\n            this.heightSegments = heightSegments || 1;\n\n            var ix, iz;\n            var width_half = width / 2;\n            var height_half = height / 2;\n\n            var gridX = this.widthSegments;\n            var gridZ = this.heightSegments;\n\n            var gridX1 = gridX + 1;\n            var gridZ1 = gridZ + 1;\n\n            var segment_width = this.width / gridX;\n            var segment_height = this.height / gridZ;\n\n            var normal = new THREE.Vector3(0, 0, 1);\n\n            for (iz = 0; iz < gridZ1; iz++) {\n\n                for (ix = 0; ix < gridX1; ix++) {\n\n                    var x = ix * segment_width - width_half;\n                    var y = iz * segment_height - height_half;\n\n                    this.vertices.push(new THREE.Vector3(x, -y, 0));\n                }\n            }\n\n            for (iz = 0; iz < gridZ; iz++) {\n\n                for (ix = 0; ix < gridX; ix++) {\n\n                    var a = ix + gridX1 * iz;\n                    var b = ix + gridX1 * (iz + 1);\n                    var c = ix + 1 + gridX1 * (iz + 1);\n                    var d = ix + 1 + gridX1 * iz;\n\n                    var uva = new THREE.Vector2(ix / gridX, 1 - iz / gridZ);\n                    var uvb = new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ);\n                    var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);\n                    var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ);\n\n                    var face = new THREE.Face3(a, b, d);\n                    face.normal.copy(normal);\n                    face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n\n                    this.faces.push(face);\n                    this.faceVertexUvs[0].push([uva, uvb, uvd]);\n\n                    face = new THREE.Face3(b, c, d);\n                    face.normal.copy(normal);\n                    face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n\n                    this.faces.push(face);\n                    this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);\n                }\n            }\n\n            // this.computeCentroids();\n        };\n\n        THREEx.Terrain.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);\n\n        var renderer = new THREE.WebGLRenderer({\n            antialias: true,\n            canvas: document.querySelector(\"#canvas3\")\n        });\n        /* Fullscreen */\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        /* Append to HTML */\n        var onRenderFcts = [];\n        var scene = new THREE.Scene();\n        var camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.01, 1000);\n        /* Play around with camera positioning */\n        camera.position.z = 15;\n        camera.position.y = 2;\n        /* Fog provides depth to the landscape*/\n        scene.fog = new THREE.Fog(0x000, 0, 45);\n        (function () {\n            var light = new THREE.AmbientLight(0x202020);\n            scene.add(light);\n            var light = new THREE.DirectionalLight('white', 5);\n            light.position.set(0.5, 0.0, 2);\n            scene.add(light);\n            var light = new THREE.DirectionalLight('white', 0.75 * 2);\n            light.position.set(-0.5, -0.5, -2);\n            scene.add(light);\n        })();\n        var heightMap = THREEx.Terrain.allocateHeightMap(256, 256);\n        THREEx.Terrain.simplexHeightMap(heightMap);\n        var geometry = THREEx.Terrain.heightMapToPlaneGeometry(heightMap);\n        THREEx.Terrain.heightMapToVertexColor(heightMap, geometry);\n        /* Wireframe built-in color is white, no need to change that */\n        var material = new THREE.MeshBasicMaterial({\n            color: '#ffffff',\n            wireframe: true\n        });\n        var mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n        mesh.lookAt(new THREE.Vector3(0, 1, 0));\n        /* Play around with the scaling */\n        mesh.scale.y = 3.5;\n        mesh.scale.x = 3;\n        mesh.scale.z = 0.20;\n        mesh.scale.multiplyScalar(10);\n        /* Play around with the camera */\n        onRenderFcts.push(function (delta, now) {\n            mesh.rotation.z += 0.025 * delta;\n        });\n        onRenderFcts.push(function () {\n            renderer.render(scene, camera);\n        });\n        var lastTimeMsec = null;\n        window.animFrame = requestAnimationFrame(function animate(nowMsec) {\n            requestAnimationFrame(animate);\n            lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;\n            var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);\n            lastTimeMsec = nowMsec;\n            onRenderFcts.forEach(function (onRenderFct) {\n                onRenderFct(deltaMsec / 1000, nowMsec / 1000);\n            });\n        });\n    });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Zyb250ZW5kL2NvbXBvbmVudHMvcGxheS9MYW5kc2NhcGUuanM/NDEzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuY2xhc3MgTGFuZHNjYXBlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgY3JlYXRlTGFuZHNjYXBlKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjb25zb2xlLmxvZygnY2FuY2VsbGVkJyk7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh3aW5kb3cuYW5pbUZyYW1lKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGNhbnZhcyBpZD1cImNhbnZhczNcIiAvPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGFuZHNjYXBlO1xuXG5mdW5jdGlvbiBjcmVhdGVMYW5kc2NhcGUoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBTaW1wbGV4Tm9pc2UgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAociA9PSB1bmRlZmluZWQpIHIgPSBNYXRoO1xuICAgICAgICAgICAgdGhpcy5ncmFkMyA9IFtcbiAgICAgICAgICAgICAgICBbMSwgMSwgMF0sXG4gICAgICAgICAgICAgICAgWy0xLCAxLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgLTEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgLTEsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbLTEsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAtMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAtMV0sXG4gICAgICAgICAgICAgICAgWzAsIDEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAtMSwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIDEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMCwgLTEsIC0xXVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGhpcy5ncmFkNCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIDEsIDEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMCwgMSwgLTEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAtMSwgLTFdLFxuICAgICAgICAgICAgICAgIFswLCAtMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIC0xLCAxLCAtMV0sXG4gICAgICAgICAgICAgICAgWzAsIC0xLCAtMSwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIC0xLCAtMSwgLTFdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAxLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgMSwgLTFdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAtMSwgMV0sXG4gICAgICAgICAgICAgICAgWzEsIDAsIC0xLCAtMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAxLCAxXSxcbiAgICAgICAgICAgICAgICBbLTEsIDAsIDEsIC0xXSxcbiAgICAgICAgICAgICAgICBbLTEsIDAsIC0xLCAxXSxcbiAgICAgICAgICAgICAgICBbLTEsIDAsIC0xLCAtMV0sXG4gICAgICAgICAgICAgICAgWzEsIDEsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAxLCAwLCAtMV0sXG4gICAgICAgICAgICAgICAgWzEsIC0xLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgLTEsIDAsIC0xXSxcbiAgICAgICAgICAgICAgICBbLTEsIDEsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFstMSwgMSwgMCwgLTFdLFxuICAgICAgICAgICAgICAgIFstMSwgLTEsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFstMSwgLTEsIDAsIC0xXSxcbiAgICAgICAgICAgICAgICBbMSwgMSwgMSwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIDEsIC0xLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgLTEsIDEsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAtMSwgLTEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgMSwgMSwgMF0sXG4gICAgICAgICAgICAgICAgWy0xLCAxLCAtMSwgMF0sXG4gICAgICAgICAgICAgICAgWy0xLCAtMSwgMSwgMF0sXG4gICAgICAgICAgICAgICAgWy0xLCAtMSwgLTEsIDBdXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB0aGlzLnAgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBbaV0gPSBNYXRoLmZsb29yKHIucmFuZG9tKCkgKiAyNTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG8gcmVtb3ZlIHRoZSBuZWVkIGZvciBpbmRleCB3cmFwcGluZywgZG91YmxlIHRoZSBwZXJtdXRhdGlvbiB0YWJsZSBsZW5ndGhcbiAgICAgICAgICAgIHRoaXMucGVybSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucGVybVtpXSA9IHRoaXMucFtpICYgMjU1XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQSBsb29rdXAgdGFibGUgdG8gdHJhdmVyc2UgdGhlIHNpbXBsZXggYXJvdW5kIGEgZ2l2ZW4gcG9pbnQgaW4gNEQuXG4gICAgICAgICAgICAvLyBEZXRhaWxzIGNhbiBiZSBmb3VuZCB3aGVyZSB0aGlzIHRhYmxlIGlzIHVzZWQsIGluIHRoZSA0RCBub2lzZSBtZXRob2QuXG4gICAgICAgICAgICB0aGlzLnNpbXBsZXggPSBbXG4gICAgICAgICAgICAgICAgWzAsIDEsIDIsIDNdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAzLCAyXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDIsIDMsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAyLCAzLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMiwgMSwgM10sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAzLCAxLCAyXSxcbiAgICAgICAgICAgICAgICBbMCwgMywgMiwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIDMsIDIsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIDIsIDAsIDNdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgMywgMCwgMl0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzIsIDMsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFsyLCAzLCAxLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgMiwgM10sXG4gICAgICAgICAgICAgICAgWzEsIDAsIDMsIDJdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsyLCAwLCAzLCAxXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzIsIDEsIDMsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzIsIDAsIDEsIDNdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFszLCAwLCAxLCAyXSxcbiAgICAgICAgICAgICAgICBbMywgMCwgMiwgMV0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFszLCAxLCAyLCAwXSxcbiAgICAgICAgICAgICAgICBbMiwgMSwgMCwgM10sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzMsIDEsIDAsIDJdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMywgMiwgMCwgMV0sXG4gICAgICAgICAgICAgICAgWzMsIDIsIDEsIDBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oZywgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGdbMF0gKiB4ICsgZ1sxXSAqIHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2ltcGxleE5vaXNlLnByb3RvdHlwZS5kb3QzID0gZnVuY3Rpb24oZywgeCwgeSwgeikge1xuICAgICAgICAgICAgcmV0dXJuIGdbMF0gKiB4ICsgZ1sxXSAqIHkgKyBnWzJdICogejtcbiAgICAgICAgfVxuXG4gICAgICAgIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUuZG90NCA9IGZ1bmN0aW9uKGcsIHgsIHksIHosIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBnWzBdICogeCArIGdbMV0gKiB5ICsgZ1syXSAqIHogKyBnWzNdICogdztcbiAgICAgICAgfTtcblxuICAgICAgICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlLm5vaXNlID0gZnVuY3Rpb24oeGluLCB5aW4pIHtcbiAgICAgICAgICAgIHZhciBuMCwgbjEsIG4yOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgICAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgICAgICAgIHZhciBGMiA9IDAuNSAqIChNYXRoLnNxcnQoMy4wKSAtIDEuMCk7XG4gICAgICAgICAgICB2YXIgcyA9ICh4aW4gKyB5aW4pICogRjI7IC8vIEhhaXJ5IGZhY3RvciBmb3IgMkRcbiAgICAgICAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4aW4gKyBzKTtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcih5aW4gKyBzKTtcbiAgICAgICAgICAgIHZhciBHMiA9ICgzLjAgLSBNYXRoLnNxcnQoMy4wKSkgLyA2LjA7XG4gICAgICAgICAgICB2YXIgdCA9IChpICsgaikgKiBHMjtcbiAgICAgICAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcbiAgICAgICAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgICAgICAgdmFyIHgwID0geGluIC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgICAgICAgIC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICAgICAgICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXG4gICAgICAgICAgICBpZiAoeDAgPiB5MCkge1xuICAgICAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICB9IC8vIGxvd2VyIHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICAgIH0gLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpXG4gICAgICAgICAgICAvLyBBIHN0ZXAgb2YgKDEsMCkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgxLWMsLWMpIGluICh4LHkpLCBhbmRcbiAgICAgICAgICAgIC8vIGEgc3RlcCBvZiAoMCwxKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKC1jLDEtYykgaW4gKHgseSksIHdoZXJlXG4gICAgICAgICAgICAvLyBjID0gKDMtc3FydCgzKSkvNlxuICAgICAgICAgICAgdmFyIHgxID0geDAgLSBpMSArIEcyOyAvLyBPZmZzZXRzIGZvciBtaWRkbGUgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHkxID0geTAgLSBqMSArIEcyO1xuICAgICAgICAgICAgdmFyIHgyID0geDAgLSAxLjAgKyAyLjAgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTIgPSB5MCAtIDEuMCArIDIuMCAqIEcyO1xuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnNcbiAgICAgICAgICAgIHZhciBpaSA9IGkgJiAyNTU7XG4gICAgICAgICAgICB2YXIgamogPSBqICYgMjU1O1xuICAgICAgICAgICAgdmFyIGdpMCA9IHRoaXMucGVybVtpaSArIHRoaXMucGVybVtqal1dICUgMTI7XG4gICAgICAgICAgICB2YXIgZ2kxID0gdGhpcy5wZXJtW2lpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMV1dICUgMTI7XG4gICAgICAgICAgICB2YXIgZ2kyID0gdGhpcy5wZXJtW2lpICsgMSArIHRoaXMucGVybVtqaiArIDFdXSAlIDEyO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAgICAgICAgICAgdmFyIHQwID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG4gICAgICAgICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQwICo9IHQwO1xuICAgICAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kwXSwgeDAsIHkwKTsgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MSA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxO1xuICAgICAgICAgICAgaWYgKHQxIDwgMCkgbjEgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSAqPSB0MTtcbiAgICAgICAgICAgICAgICBuMSA9IHQxICogdDEgKiB0aGlzLmRvdCh0aGlzLmdyYWQzW2dpMV0sIHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcbiAgICAgICAgICAgIGlmICh0MiA8IDApIG4yID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICAgICAgbjIgPSB0MiAqIHQyICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTJdLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuICAgICAgICAgICAgcmV0dXJuIDcwLjAgKiAobjAgKyBuMSArIG4yKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAzRCBzaW1wbGV4IG5vaXNlXG4gICAgICAgIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUubm9pc2UzZCA9IGZ1bmN0aW9uKHhpbiwgeWluLCB6aW4pIHtcbiAgICAgICAgICAgIHZhciBuMCwgbjEsIG4yLCBuMzsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcbiAgICAgICAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgICAgICAgIHZhciBGMyA9IDEuMCAvIDMuMDtcbiAgICAgICAgICAgIHZhciBzID0gKHhpbiArIHlpbiArIHppbikgKiBGMzsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoemluICsgcyk7XG4gICAgICAgICAgICB2YXIgRzMgPSAxLjAgLyA2LjA7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHVuc2tldyBmYWN0b3IsIHRvb1xuICAgICAgICAgICAgdmFyIHQgPSAoaSArIGogKyBrKSAqIEczO1xuICAgICAgICAgICAgdmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHopIHNwYWNlXG4gICAgICAgICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgICAgICAgIHZhciBaMCA9IGsgLSB0O1xuICAgICAgICAgICAgdmFyIHgwID0geGluIC0gWDA7IC8vIFRoZSB4LHkseiBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cbiAgICAgICAgICAgIHZhciB5MCA9IHlpbiAtIFkwO1xuICAgICAgICAgICAgdmFyIHowID0gemluIC0gWjA7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIDNEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGEgc2xpZ2h0bHkgaXJyZWd1bGFyIHRldHJhaGVkcm9uLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICAgICAgICAgICAgdmFyIGkxLCBqMSwgazE7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIGkyLCBqMiwgazI7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gICAgICAgICAgICBpZiAoeDAgPj0geTApIHtcbiAgICAgICAgICAgICAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgICAgICAgICAgICAgICAgaTEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgICAgICAgICB9IC8vIFggWSBaIG9yZGVyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDAgPj0gejApIHtcbiAgICAgICAgICAgICAgICAgICAgaTEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBqMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgICAgICAgICB9IC8vIFggWiBZIG9yZGVyXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBrMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgajIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBrMiA9IDE7XG4gICAgICAgICAgICAgICAgfSAvLyBaIFggWSBvcmRlclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8geDA8eTBcbiAgICAgICAgICAgICAgICBpZiAoeTAgPCB6MCkge1xuICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgazEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgazIgPSAxO1xuICAgICAgICAgICAgICAgIH0gLy8gWiBZIFggb3JkZXJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4MCA8IHowKSB7XG4gICAgICAgICAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgajEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgajIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBrMiA9IDE7XG4gICAgICAgICAgICAgICAgfSAvLyBZIFogWCBvcmRlclxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgazEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgazIgPSAwO1xuICAgICAgICAgICAgICAgIH0gLy8gWSBYIFogb3JkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksXG4gICAgICAgICAgICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgICAgICAgICAgIC8vIGEgc3RlcCBvZiAoMCwwLDEpIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywtYywxLWMpIGluICh4LHkseiksIHdoZXJlXG4gICAgICAgICAgICAvLyBjID0gMS82LlxuICAgICAgICAgICAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzM7XG4gICAgICAgICAgICB2YXIgejEgPSB6MCAtIGsxICsgRzM7XG4gICAgICAgICAgICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wICogRzM7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHkyID0geTAgLSBqMiArIDIuMCAqIEczO1xuICAgICAgICAgICAgdmFyIHoyID0gejAgLSBrMiArIDIuMCAqIEczO1xuICAgICAgICAgICAgdmFyIHgzID0geDAgLSAxLjAgKyAzLjAgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgICAgICAgIHZhciB5MyA9IHkwIC0gMS4wICsgMy4wICogRzM7XG4gICAgICAgICAgICB2YXIgejMgPSB6MCAtIDEuMCArIDMuMCAqIEczO1xuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuICAgICAgICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgICAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICAgICAgICB2YXIga2sgPSBrICYgMjU1O1xuICAgICAgICAgICAgdmFyIGdpMCA9IHRoaXMucGVybVtpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtra11dXSAlIDEyO1xuICAgICAgICAgICAgdmFyIGdpMSA9IHRoaXMucGVybVtpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajEgKyB0aGlzLnBlcm1ba2sgKyBrMV1dXSAlIDEyO1xuICAgICAgICAgICAgdmFyIGdpMiA9IHRoaXMucGVybVtpaSArIGkyICsgdGhpcy5wZXJtW2pqICsgajIgKyB0aGlzLnBlcm1ba2sgKyBrMl1dXSAlIDEyO1xuICAgICAgICAgICAgdmFyIGdpMyA9IHRoaXMucGVybVtpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxICsgdGhpcy5wZXJtW2trICsgMV1dXSAlIDEyO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gICAgICAgICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG4gICAgICAgICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQwICo9IHQwO1xuICAgICAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpMF0sIHgwLCB5MCwgejApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxO1xuICAgICAgICAgICAgaWYgKHQxIDwgMCkgbjEgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSAqPSB0MTtcbiAgICAgICAgICAgICAgICBuMSA9IHQxICogdDEgKiB0aGlzLmRvdDModGhpcy5ncmFkM1tnaTFdLCB4MSwgeTEsIHoxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MiA9IDAuNiAtIHgyICogeDIgLSB5MiAqIHkyIC0gejIgKiB6MjtcbiAgICAgICAgICAgIGlmICh0MiA8IDApIG4yID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICAgICAgbjIgPSB0MiAqIHQyICogdGhpcy5kb3QzKHRoaXMuZ3JhZDNbZ2kyXSwgeDIsIHkyLCB6Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG4gICAgICAgICAgICBpZiAodDMgPCAwKSBuMyA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQzICo9IHQzO1xuICAgICAgICAgICAgICAgIG4zID0gdDMgKiB0MyAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpM10sIHgzLCB5MywgejMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cbiAgICAgICAgICAgIHJldHVybiAzMi4wICogKG4wICsgbjEgKyBuMiArIG4zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyA0RCBzaW1wbGV4IG5vaXNlXG4gICAgICAgIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUubm9pc2U0ZCA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICAgICAgICAgIC8vIEZvciBmYXN0ZXIgYW5kIGVhc2llciBsb29rdXBzXG4gICAgICAgICAgICB2YXIgZ3JhZDQgPSB0aGlzLmdyYWQ0O1xuICAgICAgICAgICAgdmFyIHNpbXBsZXggPSB0aGlzLnNpbXBsZXg7XG4gICAgICAgICAgICB2YXIgcGVybSA9IHRoaXMucGVybTtcblxuICAgICAgICAgICAgLy8gVGhlIHNrZXdpbmcgYW5kIHVuc2tld2luZyBmYWN0b3JzIGFyZSBoYWlyeSBhZ2FpbiBmb3IgdGhlIDREIGNhc2VcbiAgICAgICAgICAgIHZhciBGNCA9IChNYXRoLnNxcnQoNS4wKSAtIDEuMCkgLyA0LjA7XG4gICAgICAgICAgICB2YXIgRzQgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcbiAgICAgICAgICAgIHZhciBuMCwgbjEsIG4yLCBuMywgbjQ7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAgICAgICAvLyBTa2V3IHRoZSAoeCx5LHosdykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3JlIGluXG4gICAgICAgICAgICB2YXIgcyA9ICh4ICsgeSArIHogKyB3KSAqIEY0OyAvLyBGYWN0b3IgZm9yIDREIHNrZXdpbmdcbiAgICAgICAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4ICsgcyk7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeSArIHMpO1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHogKyBzKTtcbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5mbG9vcih3ICsgcyk7XG4gICAgICAgICAgICB2YXIgdCA9IChpICsgaiArIGsgKyBsKSAqIEc0OyAvLyBGYWN0b3IgZm9yIDREIHVuc2tld2luZ1xuICAgICAgICAgICAgdmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHosdykgc3BhY2VcbiAgICAgICAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgICAgICAgdmFyIFowID0gayAtIHQ7XG4gICAgICAgICAgICB2YXIgVzAgPSBsIC0gdDtcbiAgICAgICAgICAgIHZhciB4MCA9IHggLSBYMDsgLy8gVGhlIHgseSx6LHcgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgICAgICB2YXIgeTAgPSB5IC0gWTA7XG4gICAgICAgICAgICB2YXIgejAgPSB6IC0gWjA7XG4gICAgICAgICAgICB2YXIgdzAgPSB3IC0gVzA7XG5cbiAgICAgICAgICAgIC8vIEZvciB0aGUgNEQgY2FzZSwgdGhlIHNpbXBsZXggaXMgYSA0RCBzaGFwZSBJIHdvbid0IGV2ZW4gdHJ5IHRvIGRlc2NyaWJlLlxuICAgICAgICAgICAgLy8gVG8gZmluZCBvdXQgd2hpY2ggb2YgdGhlIDI0IHBvc3NpYmxlIHNpbXBsaWNlcyB3ZSdyZSBpbiwgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBtYWduaXR1ZGUgb3JkZXJpbmcgb2YgeDAsIHkwLCB6MCBhbmQgdzAuXG4gICAgICAgICAgICAvLyBUaGUgbWV0aG9kIGJlbG93IGlzIGEgZ29vZCB3YXkgb2YgZmluZGluZyB0aGUgb3JkZXJpbmcgb2YgeCx5LHosdyBhbmRcbiAgICAgICAgICAgIC8vIHRoZW4gZmluZCB0aGUgY29ycmVjdCB0cmF2ZXJzYWwgb3JkZXIgZm9yIHRoZSBzaW1wbGV4IHdl4oCZcmUgaW4uXG4gICAgICAgICAgICAvLyBGaXJzdCwgc2l4IHBhaXItd2lzZSBjb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIGJldHdlZW4gZWFjaCBwb3NzaWJsZSBwYWlyXG4gICAgICAgICAgICAvLyBvZiB0aGUgZm91ciBjb29yZGluYXRlcywgYW5kIHRoZSByZXN1bHRzIGFyZSB1c2VkIHRvIGFkZCB1cCBiaW5hcnkgYml0c1xuICAgICAgICAgICAgLy8gZm9yIGFuIGludGVnZXIgaW5kZXguXG4gICAgICAgICAgICB2YXIgYzEgPSAoeDAgPiB5MCkgPyAzMiA6IDA7XG4gICAgICAgICAgICB2YXIgYzIgPSAoeDAgPiB6MCkgPyAxNiA6IDA7XG4gICAgICAgICAgICB2YXIgYzMgPSAoeTAgPiB6MCkgPyA4IDogMDtcbiAgICAgICAgICAgIHZhciBjNCA9ICh4MCA+IHcwKSA/IDQgOiAwO1xuICAgICAgICAgICAgdmFyIGM1ID0gKHkwID4gdzApID8gMiA6IDA7XG4gICAgICAgICAgICB2YXIgYzYgPSAoejAgPiB3MCkgPyAxIDogMDtcbiAgICAgICAgICAgIHZhciBjID0gYzEgKyBjMiArIGMzICsgYzQgKyBjNSArIGM2O1xuICAgICAgICAgICAgdmFyIGkxLCBqMSwgazEsIGwxOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgc2Vjb25kIHNpbXBsZXggY29ybmVyXG4gICAgICAgICAgICB2YXIgaTIsIGoyLCBrMiwgbDI7IC8vIFRoZSBpbnRlZ2VyIG9mZnNldHMgZm9yIHRoZSB0aGlyZCBzaW1wbGV4IGNvcm5lclxuICAgICAgICAgICAgdmFyIGkzLCBqMywgazMsIGwzOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgZm91cnRoIHNpbXBsZXggY29ybmVyXG4gICAgICAgICAgICAvLyBzaW1wbGV4W2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuXG4gICAgICAgICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XG4gICAgICAgICAgICAvLyBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9uLXplcm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS5cbiAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIDMgaW4gdGhlIFwic2ltcGxleFwiIGFycmF5IGlzIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgICAgICAgaTEgPSBzaW1wbGV4W2NdWzBdID49IDMgPyAxIDogMDtcbiAgICAgICAgICAgIGoxID0gc2ltcGxleFtjXVsxXSA+PSAzID8gMSA6IDA7XG4gICAgICAgICAgICBrMSA9IHNpbXBsZXhbY11bMl0gPj0gMyA/IDEgOiAwO1xuICAgICAgICAgICAgbDEgPSBzaW1wbGV4W2NdWzNdID49IDMgPyAxIDogMDtcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgMiBpbiB0aGUgXCJzaW1wbGV4XCIgYXJyYXkgaXMgYXQgdGhlIHNlY29uZCBsYXJnZXN0IGNvb3JkaW5hdGUuXG4gICAgICAgICAgICBpMiA9IHNpbXBsZXhbY11bMF0gPj0gMiA/IDEgOiAwO1xuICAgICAgICAgICAgajIgPSBzaW1wbGV4W2NdWzFdID49IDIgPyAxIDogMDtcbiAgICAgICAgICAgIGsyID0gc2ltcGxleFtjXVsyXSA+PSAyID8gMSA6IDA7XG4gICAgICAgICAgICBsMiA9IHNpbXBsZXhbY11bM10gPj0gMiA/IDEgOiAwO1xuICAgICAgICAgICAgLy8gVGhlIG51bWJlciAxIGluIHRoZSBcInNpbXBsZXhcIiBhcnJheSBpcyBhdCB0aGUgc2Vjb25kIHNtYWxsZXN0IGNvb3JkaW5hdGUuXG4gICAgICAgICAgICBpMyA9IHNpbXBsZXhbY11bMF0gPj0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgajMgPSBzaW1wbGV4W2NdWzFdID49IDEgPyAxIDogMDtcbiAgICAgICAgICAgIGszID0gc2ltcGxleFtjXVsyXSA+PSAxID8gMSA6IDA7XG4gICAgICAgICAgICBsMyA9IHNpbXBsZXhbY11bM10gPj0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgLy8gVGhlIGZpZnRoIGNvcm5lciBoYXMgYWxsIGNvb3JkaW5hdGUgb2Zmc2V0cyA9IDEsIHNvIG5vIG5lZWQgdG8gbG9vayB0aGF0IHVwLlxuICAgICAgICAgICAgdmFyIHgxID0geDAgLSBpMSArIEc0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgICAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHNDtcbiAgICAgICAgICAgIHZhciB6MSA9IHowIC0gazEgKyBHNDtcbiAgICAgICAgICAgIHZhciB3MSA9IHcwIC0gbDEgKyBHNDtcbiAgICAgICAgICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgICAgICAgIHZhciB5MiA9IHkwIC0gajIgKyAyLjAgKiBHNDtcbiAgICAgICAgICAgIHZhciB6MiA9IHowIC0gazIgKyAyLjAgKiBHNDtcbiAgICAgICAgICAgIHZhciB3MiA9IHcwIC0gbDIgKyAyLjAgKiBHNDtcbiAgICAgICAgICAgIHZhciB4MyA9IHgwIC0gaTMgKyAzLjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTMgPSB5MCAtIGozICsgMy4wICogRzQ7XG4gICAgICAgICAgICB2YXIgejMgPSB6MCAtIGszICsgMy4wICogRzQ7XG4gICAgICAgICAgICB2YXIgdzMgPSB3MCAtIGwzICsgMy4wICogRzQ7XG4gICAgICAgICAgICB2YXIgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTQgPSB5MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgICAgICAgdmFyIHo0ID0gejAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgICAgICAgIHZhciB3NCA9IHcwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZpdmUgc2ltcGxleCBjb3JuZXJzXG4gICAgICAgICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgICAgICAgIHZhciBrayA9IGsgJiAyNTU7XG4gICAgICAgICAgICB2YXIgbGwgPSBsICYgMjU1O1xuICAgICAgICAgICAgdmFyIGdpMCA9IHBlcm1baWkgKyBwZXJtW2pqICsgcGVybVtrayArIHBlcm1bbGxdXV1dICUgMzI7XG4gICAgICAgICAgICB2YXIgZ2kxID0gcGVybVtpaSArIGkxICsgcGVybVtqaiArIGoxICsgcGVybVtrayArIGsxICsgcGVybVtsbCArIGwxXV1dXSAlIDMyO1xuICAgICAgICAgICAgdmFyIGdpMiA9IHBlcm1baWkgKyBpMiArIHBlcm1bamogKyBqMiArIHBlcm1ba2sgKyBrMiArIHBlcm1bbGwgKyBsMl1dXV0gJSAzMjtcbiAgICAgICAgICAgIHZhciBnaTMgPSBwZXJtW2lpICsgaTMgKyBwZXJtW2pqICsgajMgKyBwZXJtW2trICsgazMgKyBwZXJtW2xsICsgbDNdXV1dICUgMzI7XG4gICAgICAgICAgICB2YXIgZ2k0ID0gcGVybVtpaSArIDEgKyBwZXJtW2pqICsgMSArIHBlcm1ba2sgKyAxICsgcGVybVtsbCArIDFdXV1dICUgMzI7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcbiAgICAgICAgICAgIHZhciB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XG4gICAgICAgICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQwICo9IHQwO1xuICAgICAgICAgICAgICAgIG4wID0gdDAgKiB0MCAqIHRoaXMuZG90NChncmFkNFtnaTBdLCB4MCwgeTAsIHowLCB3MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDEgPSAwLjYgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejEgLSB3MSAqIHcxO1xuICAgICAgICAgICAgaWYgKHQxIDwgMCkgbjEgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MSAqPSB0MTtcbiAgICAgICAgICAgICAgICBuMSA9IHQxICogdDEgKiB0aGlzLmRvdDQoZ3JhZDRbZ2kxXSwgeDEsIHkxLCB6MSwgdzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyIC0gdzIgKiB3MjtcbiAgICAgICAgICAgIGlmICh0MiA8IDApIG4yID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgICAgICAgICAgbjIgPSB0MiAqIHQyICogdGhpcy5kb3Q0KGdyYWQ0W2dpMl0sIHgyLCB5MiwgejIsIHcyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MyA9IDAuNiAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MyAtIHczICogdzM7XG4gICAgICAgICAgICBpZiAodDMgPCAwKSBuMyA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQzICo9IHQzO1xuICAgICAgICAgICAgICAgIG4zID0gdDMgKiB0MyAqIHRoaXMuZG90NChncmFkNFtnaTNdLCB4MywgeTMsIHozLCB3Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDQgPSAwLjYgLSB4NCAqIHg0IC0geTQgKiB5NCAtIHo0ICogejQgLSB3NCAqIHc0O1xuICAgICAgICAgICAgaWYgKHQ0IDwgMCkgbjQgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0NCAqPSB0NDtcbiAgICAgICAgICAgICAgICBuNCA9IHQ0ICogdDQgKiB0aGlzLmRvdDQoZ3JhZDRbZ2k0XSwgeDQsIHk0LCB6NCwgdzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3VtIHVwIGFuZCBzY2FsZSB0aGUgcmVzdWx0IHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV1cbiAgICAgICAgICAgIHJldHVybiAyNy4wICogKG4wICsgbjEgKyBuMiArIG4zICsgbjQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBUSFJFRXggPSBUSFJFRXggfHwge31cblxuICAgICAgICBUSFJFRXguVGVycmFpbiA9IHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFsbG9jYXRlIHRoZSBoZWlnaHRtYXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgdGhlIGhlaWdodG1hcFxuICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlcHRoIHRoZSBkZXB0aCBvZiB0aGUgaGVpZ2h0bWFwXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSB0aGUgYWxsb2NhdGVkIGhlaWdodG1hcFxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uYWxsb2NhdGVIZWlnaHRNYXAgPSBmdW5jdGlvbih3aWR0aCwgZGVwdGgpIHtcbiAgICAgICAgICAgIHZhciBBcnJheUNsYXNzID0gVEhSRUV4LlRlcnJhaW4uYWxsb2NhdGVIZWlnaHRNYXAuQXJyYXlDbGFzc1xuICAgICAgICAgICAgdmFyIGhlaWdodE1hcCA9IG5ldyBBcnJheSh3aWR0aClcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGhlaWdodE1hcFt4XSA9IG5ldyBBcnJheUNsYXNzKGRlcHRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlaWdodE1hcFxuICAgICAgICB9XG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmFsbG9jYXRlSGVpZ2h0TWFwLkFycmF5Q2xhc3MgPSB3aW5kb3cuRmxvYXQ2NEFycmF5IHx8IHdpbmRvdy5BcnJheVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZW5lcmF0ZSBhIGhlaWdodG1hcCB1c2luZyBhIHNpbXBsZXggbm9pc2VcbiAgICAgICAgICogQHRvZG8gbWFrZSBpdCBpdCB0dW5hYmxlLi4uIGhvdyA/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBoZWlnaHRNYXAgdGhlIGhlaWdodG1hcCB0byBzdG9yZSB0aGUgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uc2ltcGxleEhlaWdodE1hcCA9IGZ1bmN0aW9uKGhlaWdodE1hcCkge1xuICAgICAgICAgICAgLy8gZ2V0IGhlaWdodE1hcCBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBoZWlnaHRNYXAubGVuZ3RoXG4gICAgICAgICAgICB2YXIgZGVwdGggPSBoZWlnaHRNYXBbMF0ubGVuZ3RoXG5cbiAgICAgICAgICAgIHZhciBzaW1wbGV4ID0gbmV3IFNpbXBsZXhOb2lzZSgpXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGRlcHRoOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSAwXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IDhcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IChzaW1wbGV4Lm5vaXNlKHggLyBsZXZlbCwgeiAvIGxldmVsKSAvIDIgKyAwLjUpICogMC4xMjVcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgKj0gM1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gKHNpbXBsZXgubm9pc2UoeCAvIGxldmVsLCB6IC8gbGV2ZWwpIC8gMiArIDAuNSkgKiAwLjI1XG4gICAgICAgICAgICAgICAgICAgIGxldmVsICo9IDJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IChzaW1wbGV4Lm5vaXNlKHggLyBsZXZlbCwgeiAvIGxldmVsKSAvIDIgKyAwLjUpICogMC41XG4gICAgICAgICAgICAgICAgICAgIGxldmVsICo9IDJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IChzaW1wbGV4Lm5vaXNlKHggLyBsZXZlbCwgeiAvIGxldmVsKSAvIDIgKyAwLjUpICogMVxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLz0gMSArIDAuNSArIDAuMjUgKyAwLjEyNVxuICAgICAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGhlaWdodCBpbiB0aGUgaGVpZ2h0TWFwXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodE1hcFt4XVt6XSA9IGhlaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBidWlsZCBhIGNhbnZhcyAyZCBmcm9tIGEgaGVpZ2h0bWFwXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBoZWlnaHRNYXAgaGVpZ2h0bWFwXG4gICAgICAgICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fHVuZGVmaW5lZH0gY2FudmFzICB0aGUgZGVzdGluYXRpb24gY2FudmFzLlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gICAgICAgICAgIHRoZSBjYW52YXNcbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmhlaWdodE1hcFRvQ2FudmFzID0gZnVuY3Rpb24oaGVpZ2h0TWFwLCBjYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuICAgICAgICAgICAgLy8gY3JlYXRlIGNhbnZhc1xuICAgICAgICAgICAgY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGRlcHRoXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAvLyBsb29wIG9uIGVhY2ggcGl4ZWwgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHRNYXBbeF1beV1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gVEhSRUV4LlRlcnJhaW4uaGVpZ2h0VG9Db2xvcihoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IuZ2V0U3R5bGUoKVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIDEsIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBqdXN0IGJ1aWx0IGNhbnZhc1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGEgVEhSRUUuUGxhbmVHZW9tZXRyeSBiYXNlZCBvbiBhIGhlaWdodE1hcFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gaGVpZ2h0TWFwIHRoZSBoZWlnaHRtYXBcbiAgICAgICAgICogQHJldHVybiB7VEhSRUUuR2VvbWV0cnl9ICB0aGUganVzdCBidWlsdCBnZW9tZXRyeVxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24oaGVpZ2h0TWFwKSB7XG4gICAgICAgICAgICAvLyBnZXQgaGVpZ2h0TWFwIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodE1hcC5sZW5ndGhcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGhlaWdodE1hcFswXS5sZW5ndGhcbiAgICAgICAgICAgIC8vIGJ1aWxkIGdlb21ldHJ5XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUV4LlRlcnJhaW4uUGxhbmVHZW9tZXRyeSgxLCAxLCB3aWR0aCAtIDEsIGRlcHRoIC0gMSlcbiAgICAgICAgICAgIC8vIGxvb3Agb24gZWFjaCB2ZXJ0ZXggb2YgdGhlIGdlb21ldHJ5XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGRlcHRoOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBoZWlnaHQgZnJvbSBoZWlnaHRNYXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGhlaWdodE1hcFt4XVt6XVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHZlcnRleC56IHRvIGEgbm9ybWFsaXplZCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IGdlb21ldHJ5LnZlcnRpY2VzW3ggKyB6ICogd2lkdGhdXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleC56ID0gKGhlaWdodCAtIDAuNSkgKiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBnZW9tZXRyeSBuZWVkIHRvIHVwZGF0ZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBnZW9tZXRyeSBuZWVkIHRvIHVwZGF0ZSBub3JtYWxzXG4gICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKVxuICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKVxuICAgICAgICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGp1c3QgYnVpbHQgZ2VvbWV0cnlcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeVxuICAgICAgICB9XG5cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9IZWlnaHQgPSBmdW5jdGlvbihoZWlnaHRNYXAsIHgsIHopIHtcbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuICAgICAgICAgICAgLy8gc2FuaXR5IGNoZWNrIC0gYm91bmRhcmllc1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoeCA+PSAwICYmIHggPCB3aWR0aClcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHogPj0gMCAmJiB6IDwgZGVwdGgpXG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGVsdGEgd2l0aGluIGEgc2luZ2xlIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSB4IC0gTWF0aC5mbG9vcih4KVxuICAgICAgICAgICAgdmFyIGRlbHRhWiA9IHogLSBNYXRoLmZsb29yKHopXG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgaGVpZ2h0IG9mIGVhY2ggY29ybmVyIG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgaGVpZ2h0TlcgPSBoZWlnaHRNYXBbTWF0aC5mbG9vcih4KV1bTWF0aC5mbG9vcih6KV1cbiAgICAgICAgICAgIHZhciBoZWlnaHRORSA9IGhlaWdodE1hcFtNYXRoLmNlaWwoeCldW01hdGguZmxvb3IoeildXG4gICAgICAgICAgICB2YXIgaGVpZ2h0U1cgPSBoZWlnaHRNYXBbTWF0aC5mbG9vcih4KV1bTWF0aC5jZWlsKHopXVxuICAgICAgICAgICAgdmFyIGhlaWdodFNFID0gaGVpZ2h0TWFwW01hdGguY2VpbCh4KV1bTWF0aC5jZWlsKHopXVxuXG4gICAgICAgICAgICAvLyB0ZXN0IGluIHdoaWNoIHRyaWFuZ2xlIHRoZSBwb2ludCBpcy4gbm9ydGgtZWFzdCBvciBzb3V0aC13ZXN0XG4gICAgICAgICAgICB2YXIgaW5UcmlhbmdsZU5FID0gZGVsdGFYID4gZGVsdGFaID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgICBpZiAoaW5UcmlhbmdsZU5FKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGhlaWdodE5FICtcbiAgICAgICAgICAgICAgICAgICAgKGhlaWdodE5XIC0gaGVpZ2h0TkUpICogKDEgLSBkZWx0YVgpICtcbiAgICAgICAgICAgICAgICAgICAgKGhlaWdodFNFIC0gaGVpZ2h0TkUpICogZGVsdGFaXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHRTVyArXG4gICAgICAgICAgICAgICAgICAgIChoZWlnaHRTRSAtIGhlaWdodFNXKSAqIGRlbHRhWCArXG4gICAgICAgICAgICAgICAgICAgIChoZWlnaHROVyAtIGhlaWdodFNXKSAqICgxIC0gZGVsdGFaKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBoZWlnaHRcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLnBsYW5lVG9IZWlnaHRNYXBDb29yZHMgPSBmdW5jdGlvbihoZWlnaHRNYXAsIHBsYW5lTWVzaCwgeCwgeikge1xuXG4gICAgICAgICAgICAvLyBUT0RPIGFzc2VydCBubyByb3RhdGlvbiBpbiBwbGFuZU1lc2hcbiAgICAgICAgICAgIC8vIC0gaG93IGNhbiBpIGNoZWNrIHRoYXQgPyB3aXRoIGV1bGVyID9cblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoeCwgMCwgeilcblxuICAgICAgICAgICAgLy8gc2V0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBsYW5lTWVzaCBwb3NpdGlvblxuICAgICAgICAgICAgcG9zaXRpb24uc3ViKHBsYW5lTWVzaC5wb3NpdGlvbilcblxuICAgICAgICAgICAgLy8gaGVpZ2h0TWFwIG9yaWdpbiBpcyBhdCBpdHMgdG9wLWxlZnQsIHdoaWxlIHBsYW5lTWVzaCBvcmlnaW4gaXMgYXQgaXRzIGNlbnRlclxuICAgICAgICAgICAgcG9zaXRpb24ueCArPSBwbGFuZU1lc2guZ2VvbWV0cnkud2lkdGggLyAyICogcGxhbmVNZXNoLnNjYWxlLnhcbiAgICAgICAgICAgIHBvc2l0aW9uLnogKz0gcGxhbmVNZXNoLmdlb21ldHJ5LmhlaWdodCAvIDIgKiBwbGFuZU1lc2guc2NhbGUueVxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgaXQgZnJvbSBbMCwxXSBmb3IgdGhlIGhlaWdodG1hcFxuICAgICAgICAgICAgcG9zaXRpb24ueCAvPSBwbGFuZU1lc2guZ2VvbWV0cnkud2lkdGggKiBwbGFuZU1lc2guc2NhbGUueFxuICAgICAgICAgICAgcG9zaXRpb24ueiAvPSBwbGFuZU1lc2guZ2VvbWV0cnkuaGVpZ2h0ICogcGxhbmVNZXNoLnNjYWxlLnlcblxuICAgICAgICAgICAgLy8gZ2V0IGhlaWdodE1hcCBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBoZWlnaHRNYXAubGVuZ3RoXG4gICAgICAgICAgICB2YXIgZGVwdGggPSBoZWlnaHRNYXBbMF0ubGVuZ3RoXG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaXQgaW4gaGVpZ2h0TWFwIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKj0gKHdpZHRoIC0gMSlcbiAgICAgICAgICAgIHBvc2l0aW9uLnogKj0gKGRlcHRoIC0gMSlcblxuICAgICAgICAgICAgcG9zaXRpb24ueSA9IFRIUkVFeC5UZXJyYWluLmhlaWdodE1hcFRvSGVpZ2h0KGhlaWdodE1hcCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueilcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSAocG9zaXRpb24ueSAtIDAuNSkgKiAyXG4gICAgICAgICAgICBwb3NpdGlvbi55ICo9IHBsYW5lTWVzaC5zY2FsZS56XG5cbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbi55XG4gICAgICAgIH1cblxuICAgICAgICBUSFJFRXguVGVycmFpbi5wbGFuZVRvSGVpZ2h0TWFwQ29vcmRzMCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBoZWlnaHRNYXAsIHBsYW5lTWVzaCkge1xuXG4gICAgICAgICAgICAvLyBUT0RPIGFzc2VydCBubyByb3RhdGlvbiBpbiBwbGFuZU1lc2hcbiAgICAgICAgICAgIC8vIC0gaG93IGNhbiBpIGNoZWNrIHRoYXQgPyB3aXRoIGV1bGVyID9cblxuICAgICAgICAgICAgLy8gc2V0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBsYW5lTWVzaCBwb3NpdGlvblxuICAgICAgICAgICAgcG9zaXRpb24uc3ViKHBsYW5lTWVzaC5wb3NpdGlvbilcblxuICAgICAgICAgICAgLy8gaGVpZ2h0TWFwIG9yaWdpbiBpcyBhdCBpdHMgdG9wLWxlZnQsIHdoaWxlIHBsYW5lTWVzaCBvcmlnaW4gaXMgYXQgaXRzIGNlbnRlclxuICAgICAgICAgICAgcG9zaXRpb24ueCArPSBwbGFuZU1lc2guZ2VvbWV0cnkud2lkdGggLyAyXG4gICAgICAgICAgICBwb3NpdGlvbi56ICs9IHBsYW5lTWVzaC5nZW9tZXRyeS5oZWlnaHQgLyAyXG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBpdCBmcm9tIFswLDFdIGZvciB0aGUgaGVpZ2h0bWFwXG4gICAgICAgICAgICBwb3NpdGlvbi54IC89IHBsYW5lTWVzaC5nZW9tZXRyeS53aWR0aFxuICAgICAgICAgICAgcG9zaXRpb24ueiAvPSBwbGFuZU1lc2guZ2VvbWV0cnkuaGVpZ2h0XG5cbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGl0IGluIGhlaWdodE1hcCBjb29yZGluYXRlXG4gICAgICAgICAgICBwb3NpdGlvbi54ICo9ICh3aWR0aCAtIDEpXG4gICAgICAgICAgICBwb3NpdGlvbi56ICo9IChkZXB0aCAtIDEpXG5cbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb0hlaWdodChoZWlnaHRNYXAsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnopXG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gKGhlaWdodCAtIDAuNSkgKiAyXG5cbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHZlcnRleCBjb2xvciBmb3IgYSBUSFJFRS5HZW9tZXRyeSBiYXNlZCBvbiBhIGhlaWdodE1hcFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gaGVpZ2h0TWFwIHRoZSBoZWlnaHRtYXBcbiAgICAgICAgICogQHBhcmFtICB7VEhSRUUuR2VvbWV0cnl9IGdlb21ldHJ5ICB0aGUgZ2VvbWV0cnkgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb1ZlcnRleENvbG9yID0gZnVuY3Rpb24oaGVpZ2h0TWFwLCBnZW9tZXRyeSkge1xuICAgICAgICAgICAgLy8gZ2V0IGhlaWdodE1hcCBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBoZWlnaHRNYXAubGVuZ3RoXG4gICAgICAgICAgICB2YXIgZGVwdGggPSBoZWlnaHRNYXBbMF0ubGVuZ3RoXG4gICAgICAgICAgICAvLyBsb29wIG9uIGVhY2ggdmVydGV4IG9mIHRoZSBnZW9tZXRyeVxuICAgICAgICAgICAgdmFyIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGdlb21ldHJ5LmZhY2VzW2ldXG4gICAgICAgICAgICAgICAgaWYgKGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQpXG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2godmVydGV4SWR4VG9Db2xvcihmYWNlLmEpLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2godmVydGV4SWR4VG9Db2xvcihmYWNlLmIpLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2godmVydGV4SWR4VG9Db2xvcihmYWNlLmMpLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2godmVydGV4SWR4VG9Db2xvcihmYWNlLmQpLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5hKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5iKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5jKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBjb25zb2xlLmFzc2VydChmYWxzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgZnVuY3Rpb24gdmVydGV4SWR4VG9Db2xvcih2ZXJ0ZXhJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IodmVydGV4SWR4ICUgd2lkdGgpXG4gICAgICAgICAgICAgICAgdmFyIHogPSBNYXRoLmZsb29yKHZlcnRleElkeCAvIHdpZHRoKVxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHRNYXBbeF1bel1cbiAgICAgICAgICAgICAgICByZXR1cm4gVEhSRUV4LlRlcnJhaW4uaGVpZ2h0VG9Db2xvcihoZWlnaHQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2l2ZSBhIGNvbG9yIGJhc2VkIG9uIGEgZ2l2ZW4gaGVpZ2h0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgdGhlIGhlaWdodFxuICAgICAgICAgKiBAcmV0dXJuIHtUSFJFRS5Db2xvcn0gdGhlIGNvbG9yIGZvciB0aGlzIGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uaGVpZ2h0VG9Db2xvciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBjb2xvciBiYXNlZCBvbiBoZWlnaHRcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgKiAyKSAqIDAuNSArIDAuMlxuICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRSR0IoMCwgMCwgaGVpZ2h0KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMC43KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgLSAwLjUpIC8gMC4yXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAqIDAuNSArIDAuMlxuICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRSR0IoMCwgaGVpZ2h0LCAwKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgLSAwLjcpIC8gMC4zXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAqIDAuNSArIDAuNVxuICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRSR0IoaGVpZ2h0LCBoZWlnaHQsIGhlaWdodClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29sb3Iuc2V0UkdCKDEsMSwxKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuXG5cbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvL1x0XHRjb21tZW50XHRcdFx0XHRcdFx0XHRcdC8vXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvKipcbiAgICAgICAgICogcGxhbmUgZ2VvbWV0cnkgd2l0aCBUSFJFRS5GYWNlMyBmcm9tIHRocmVlLmpzIHI2NlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gd2lkdGggICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gaGVpZ2h0ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gd2lkdGhTZWdtZW50cyAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcGFyYW0ge1t0eXBlXX0gaGVpZ2h0U2VnbWVudHMgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzKSB7XG5cbiAgICAgICAgICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblxuICAgICAgICAgICAgdmFyIGl4LCBpejtcbiAgICAgICAgICAgIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgdmFyIGdyaWRYID0gdGhpcy53aWR0aFNlZ21lbnRzO1xuICAgICAgICAgICAgdmFyIGdyaWRaID0gdGhpcy5oZWlnaHRTZWdtZW50cztcblxuICAgICAgICAgICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcbiAgICAgICAgICAgIHZhciBncmlkWjEgPSBncmlkWiArIDE7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50X3dpZHRoID0gdGhpcy53aWR0aCAvIGdyaWRYO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRfaGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyBncmlkWjtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuXG4gICAgICAgICAgICBmb3IgKGl6ID0gMDsgaXogPCBncmlkWjE7IGl6KyspIHtcblxuICAgICAgICAgICAgICAgIGZvciAoaXggPSAwOyBpeCA8IGdyaWRYMTsgaXgrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBpeiAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHgsIC15LCAwKSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpeiA9IDA7IGl6IDwgZ3JpZFo7IGl6KyspIHtcblxuICAgICAgICAgICAgICAgIGZvciAoaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl6O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKGl6ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gKGl4ICsgMSkgKyBncmlkWDEgKiAoaXogKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoaXggKyAxKSArIGdyaWRYMSAqIGl6O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMihpeCAvIGdyaWRYLCAxIC0gaXogLyBncmlkWik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMihpeCAvIGdyaWRYLCAxIC0gKGl6ICsgMSkgLyBncmlkWik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMigoaXggKyAxKSAvIGdyaWRYLCAxIC0gKGl6ICsgMSkgLyBncmlkWik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMigoaXggKyAxKSAvIGdyaWRYLCAxIC0gaXogLyBncmlkWik7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoYSwgYiwgZCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkobm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2gobm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKGZhY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbdXZhLCB1dmIsIHV2ZF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoYiwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2Uubm9ybWFsLmNvcHkobm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2gobm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKGZhY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCldKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1xuXG4gICAgICAgIHZhciByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbnZhczogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW52YXMzXCIpXG4gICAgICAgIH0pO1xuICAgICAgICAvKiBGdWxsc2NyZWVuICovXG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIC8qIEFwcGVuZCB0byBIVE1MICovXG4gICAgICAgIHZhciBvblJlbmRlckZjdHMgPSBbXTtcbiAgICAgICAgdmFyIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoMjUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjAxLCAxMDAwKTtcbiAgICAgICAgLyogUGxheSBhcm91bmQgd2l0aCBjYW1lcmEgcG9zaXRpb25pbmcgKi9cbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSAxNTtcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgPSAyO1xuICAgICAgICAvKiBGb2cgcHJvdmlkZXMgZGVwdGggdG8gdGhlIGxhbmRzY2FwZSovXG4gICAgICAgIHNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2coMHgwMDAsIDAsIDQ1KTtcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDIwMjAyMClcbiAgICAgICAgICAgIHNjZW5lLmFkZChsaWdodClcbiAgICAgICAgICAgIHZhciBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCd3aGl0ZScsIDUpXG4gICAgICAgICAgICBsaWdodC5wb3NpdGlvbi5zZXQoMC41LCAwLjAsIDIpXG4gICAgICAgICAgICBzY2VuZS5hZGQobGlnaHQpXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgnd2hpdGUnLCAwLjc1ICogMilcbiAgICAgICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgtMC41LCAtMC41LCAtMilcbiAgICAgICAgICAgIHNjZW5lLmFkZChsaWdodClcbiAgICAgICAgfSkoKVxuICAgICAgICB2YXIgaGVpZ2h0TWFwID0gVEhSRUV4LlRlcnJhaW4uYWxsb2NhdGVIZWlnaHRNYXAoMjU2LCAyNTYpXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLnNpbXBsZXhIZWlnaHRNYXAoaGVpZ2h0TWFwKVxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb1BsYW5lR2VvbWV0cnkoaGVpZ2h0TWFwKVxuICAgICAgICBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb1ZlcnRleENvbG9yKGhlaWdodE1hcCwgZ2VvbWV0cnkpXG4gICAgICAgIC8qIFdpcmVmcmFtZSBidWlsdC1pbiBjb2xvciBpcyB3aGl0ZSwgbm8gbmVlZCB0byBjaGFuZ2UgdGhhdCAqL1xuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICBzY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIG1lc2gubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApKTtcbiAgICAgICAgLyogUGxheSBhcm91bmQgd2l0aCB0aGUgc2NhbGluZyAqL1xuICAgICAgICBtZXNoLnNjYWxlLnkgPSAzLjU7XG4gICAgICAgIG1lc2guc2NhbGUueCA9IDM7XG4gICAgICAgIG1lc2guc2NhbGUueiA9IDAuMjA7XG4gICAgICAgIG1lc2guc2NhbGUubXVsdGlwbHlTY2FsYXIoMTApO1xuICAgICAgICAvKiBQbGF5IGFyb3VuZCB3aXRoIHRoZSBjYW1lcmEgKi9cbiAgICAgICAgb25SZW5kZXJGY3RzLnB1c2goZnVuY3Rpb24oZGVsdGEsIG5vdykge1xuICAgICAgICAgICAgbWVzaC5yb3RhdGlvbi56ICs9IDAuMDI1ICogZGVsdGE7XG4gICAgICAgIH0pXG4gICAgICAgIG9uUmVuZGVyRmN0cy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgICB9KVxuICAgICAgICB2YXIgbGFzdFRpbWVNc2VjID0gbnVsbFxuICAgICAgICB3aW5kb3cuYW5pbUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUobm93TXNlYykge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgICAgICAgbGFzdFRpbWVNc2VjID0gbGFzdFRpbWVNc2VjIHx8IG5vd01zZWMgLSAxMDAwIC8gNjBcbiAgICAgICAgICAgIHZhciBkZWx0YU1zZWMgPSBNYXRoLm1pbigyMDAsIG5vd01zZWMgLSBsYXN0VGltZU1zZWMpXG4gICAgICAgICAgICBsYXN0VGltZU1zZWMgPSBub3dNc2VjXG4gICAgICAgICAgICBvblJlbmRlckZjdHMuZm9yRWFjaChmdW5jdGlvbihvblJlbmRlckZjdCkge1xuICAgICAgICAgICAgICAgIG9uUmVuZGVyRmN0KGRlbHRhTXNlYyAvIDEwMDAsIG5vd01zZWMgLyAxMDAwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGZyb250ZW5kL2NvbXBvbmVudHMvcGxheS9MYW5kc2NhcGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTs7O0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUdBOzs7O0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })

})