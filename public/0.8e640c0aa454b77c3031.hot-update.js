webpackHotUpdate(0,{

/***/ 360:
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./frontend/components/play/Landscape.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ 1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ 2);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _three = __webpack_require__(/*! three */ 197);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Landscape = function (_React$Component) {\n    _inherits(Landscape, _React$Component);\n\n    function Landscape(props) {\n        _classCallCheck(this, Landscape);\n\n        return _possibleConstructorReturn(this, (Landscape.__proto__ || Object.getPrototypeOf(Landscape)).call(this, props));\n    }\n\n    _createClass(Landscape, [{\n        key: 'componentWillMount',\n        value: function componentWillMount() {\n            createLandscape();\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement('canvas', { id: 'canvas3' });\n        }\n    }]);\n\n    return Landscape;\n}(_react2.default.Component);\n\nexports.default = Landscape;\n\n\nfunction createLandscape() {\n    setTimeout(function () {\n        var SimplexNoise = function SimplexNoise(r) {\n            if (r == undefined) r = Math;\n            this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];\n\n            this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];\n\n            this.p = [];\n            for (var i = 0; i < 256; i++) {\n                this.p[i] = Math.floor(r.random() * 256);\n            }\n            // To remove the need for index wrapping, double the permutation table length\n            this.perm = [];\n            for (var i = 0; i < 512; i++) {\n                this.perm[i] = this.p[i & 255];\n            }\n\n            // A lookup table to traverse the simplex around a given point in 4D.\n            // Details can be found where this table is used, in the 4D noise method.\n            this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];\n        };\n\n        SimplexNoise.prototype.dot = function (g, x, y) {\n            return g[0] * x + g[1] * y;\n        };\n\n        SimplexNoise.prototype.dot3 = function (g, x, y, z) {\n            return g[0] * x + g[1] * y + g[2] * z;\n        };\n\n        SimplexNoise.prototype.dot4 = function (g, x, y, z, w) {\n            return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n        };\n\n        SimplexNoise.prototype.noise = function (xin, yin) {\n            var n0, n1, n2; // Noise contributions from the three corners\n            // Skew the input space to determine which simplex cell we're in\n            var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\n            var s = (xin + yin) * F2; // Hairy factor for 2D\n            var i = Math.floor(xin + s);\n            var j = Math.floor(yin + s);\n            var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\n            var t = (i + j) * G2;\n            var X0 = i - t; // Unskew the cell origin back to (x,y) space\n            var Y0 = j - t;\n            var x0 = xin - X0; // The x,y distances from the cell origin\n            var y0 = yin - Y0;\n            // For the 2D case, the simplex shape is an equilateral triangle.\n            // Determine which simplex we are in.\n            var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n            if (x0 > y0) {\n                i1 = 1;\n                j1 = 0;\n            } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n            else {\n                    i1 = 0;\n                    j1 = 1;\n                } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n            // c = (3-sqrt(3))/6\n            var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n            var y1 = y0 - j1 + G2;\n            var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n            var y2 = y0 - 1.0 + 2.0 * G2;\n            // Work out the hashed gradient indices of the three simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var gi0 = this.perm[ii + this.perm[jj]] % 12;\n            var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;\n            var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;\n            // Calculate the contribution from the three corners\n            var t0 = 0.5 - x0 * x0 - y0 * y0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n            }\n            var t1 = 0.5 - x1 * x1 - y1 * y1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n            }\n            var t2 = 0.5 - x2 * x2 - y2 * y2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n            }\n            // Add contributions from each corner to get the final noise value.\n            // The result is scaled to return values in the interval [-1,1].\n            return 70.0 * (n0 + n1 + n2);\n        };\n\n        // 3D simplex noise\n        SimplexNoise.prototype.noise3d = function (xin, yin, zin) {\n            var n0, n1, n2, n3; // Noise contributions from the four corners\n            // Skew the input space to determine which simplex cell we're in\n            var F3 = 1.0 / 3.0;\n            var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\n            var i = Math.floor(xin + s);\n            var j = Math.floor(yin + s);\n            var k = Math.floor(zin + s);\n            var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n            var t = (i + j + k) * G3;\n            var X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n            var Y0 = j - t;\n            var Z0 = k - t;\n            var x0 = xin - X0; // The x,y,z distances from the cell origin\n            var y0 = yin - Y0;\n            var z0 = zin - Z0;\n            // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n            // Determine which simplex we are in.\n            var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n            var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n            if (x0 >= y0) {\n                if (y0 >= z0) {\n                    i1 = 1;\n                    j1 = 0;\n                    k1 = 0;\n                    i2 = 1;\n                    j2 = 1;\n                    k2 = 0;\n                } // X Y Z order\n                else if (x0 >= z0) {\n                        i1 = 1;\n                        j1 = 0;\n                        k1 = 0;\n                        i2 = 1;\n                        j2 = 0;\n                        k2 = 1;\n                    } // X Z Y order\n                    else {\n                            i1 = 0;\n                            j1 = 0;\n                            k1 = 1;\n                            i2 = 1;\n                            j2 = 0;\n                            k2 = 1;\n                        } // Z X Y order\n            } else {\n                // x0<y0\n                if (y0 < z0) {\n                    i1 = 0;\n                    j1 = 0;\n                    k1 = 1;\n                    i2 = 0;\n                    j2 = 1;\n                    k2 = 1;\n                } // Z Y X order\n                else if (x0 < z0) {\n                        i1 = 0;\n                        j1 = 1;\n                        k1 = 0;\n                        i2 = 0;\n                        j2 = 1;\n                        k2 = 1;\n                    } // Y Z X order\n                    else {\n                            i1 = 0;\n                            j1 = 1;\n                            k1 = 0;\n                            i2 = 1;\n                            j2 = 1;\n                            k2 = 0;\n                        } // Y X Z order\n            }\n            // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n            // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n            // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n            // c = 1/6.\n            var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n            var y1 = y0 - j1 + G3;\n            var z1 = z0 - k1 + G3;\n            var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n            var y2 = y0 - j2 + 2.0 * G3;\n            var z2 = z0 - k2 + 2.0 * G3;\n            var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n            var y3 = y0 - 1.0 + 3.0 * G3;\n            var z3 = z0 - 1.0 + 3.0 * G3;\n            // Work out the hashed gradient indices of the four simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var kk = k & 255;\n            var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\n            var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\n            var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\n            var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;\n            // Calculate the contribution from the four corners\n            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n            }\n            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n            }\n            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n            }\n            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n            if (t3 < 0) n3 = 0.0;else {\n                t3 *= t3;\n                n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n            }\n            // Add contributions from each corner to get the final noise value.\n            // The result is scaled to stay just inside [-1,1]\n            return 32.0 * (n0 + n1 + n2 + n3);\n        };\n\n        // 4D simplex noise\n        SimplexNoise.prototype.noise4d = function (x, y, z, w) {\n            // For faster and easier lookups\n            var grad4 = this.grad4;\n            var simplex = this.simplex;\n            var perm = this.perm;\n\n            // The skewing and unskewing factors are hairy again for the 4D case\n            var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\n            var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n            var n0, n1, n2, n3, n4; // Noise contributions from the five corners\n            // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n            var s = (x + y + z + w) * F4; // Factor for 4D skewing\n            var i = Math.floor(x + s);\n            var j = Math.floor(y + s);\n            var k = Math.floor(z + s);\n            var l = Math.floor(w + s);\n            var t = (i + j + k + l) * G4; // Factor for 4D unskewing\n            var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n            var Y0 = j - t;\n            var Z0 = k - t;\n            var W0 = l - t;\n            var x0 = x - X0; // The x,y,z,w distances from the cell origin\n            var y0 = y - Y0;\n            var z0 = z - Z0;\n            var w0 = w - W0;\n\n            // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n            // To find out which of the 24 possible simplices we're in, we need to\n            // determine the magnitude ordering of x0, y0, z0 and w0.\n            // The method below is a good way of finding the ordering of x,y,z,w and\n            // then find the correct traversal order for the simplex we’re in.\n            // First, six pair-wise comparisons are performed between each possible pair\n            // of the four coordinates, and the results are used to add up binary bits\n            // for an integer index.\n            var c1 = x0 > y0 ? 32 : 0;\n            var c2 = x0 > z0 ? 16 : 0;\n            var c3 = y0 > z0 ? 8 : 0;\n            var c4 = x0 > w0 ? 4 : 0;\n            var c5 = y0 > w0 ? 2 : 0;\n            var c6 = z0 > w0 ? 1 : 0;\n            var c = c1 + c2 + c3 + c4 + c5 + c6;\n            var i1, j1, k1, l1; // The integer offsets for the second simplex corner\n            var i2, j2, k2, l2; // The integer offsets for the third simplex corner\n            var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n            // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n            // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n            // impossible. Only the 24 indices which have non-zero entries make any sense.\n            // We use a thresholding to set the coordinates in turn from the largest magnitude.\n            // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n            i1 = simplex[c][0] >= 3 ? 1 : 0;\n            j1 = simplex[c][1] >= 3 ? 1 : 0;\n            k1 = simplex[c][2] >= 3 ? 1 : 0;\n            l1 = simplex[c][3] >= 3 ? 1 : 0;\n            // The number 2 in the \"simplex\" array is at the second largest coordinate.\n            i2 = simplex[c][0] >= 2 ? 1 : 0;\n            j2 = simplex[c][1] >= 2 ? 1 : 0;\n            k2 = simplex[c][2] >= 2 ? 1 : 0;\n            l2 = simplex[c][3] >= 2 ? 1 : 0;\n            // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n            i3 = simplex[c][0] >= 1 ? 1 : 0;\n            j3 = simplex[c][1] >= 1 ? 1 : 0;\n            k3 = simplex[c][2] >= 1 ? 1 : 0;\n            l3 = simplex[c][3] >= 1 ? 1 : 0;\n            // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n            var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n            var y1 = y0 - j1 + G4;\n            var z1 = z0 - k1 + G4;\n            var w1 = w0 - l1 + G4;\n            var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n            var y2 = y0 - j2 + 2.0 * G4;\n            var z2 = z0 - k2 + 2.0 * G4;\n            var w2 = w0 - l2 + 2.0 * G4;\n            var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n            var y3 = y0 - j3 + 3.0 * G4;\n            var z3 = z0 - k3 + 3.0 * G4;\n            var w3 = w0 - l3 + 3.0 * G4;\n            var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n            var y4 = y0 - 1.0 + 4.0 * G4;\n            var z4 = z0 - 1.0 + 4.0 * G4;\n            var w4 = w0 - 1.0 + 4.0 * G4;\n            // Work out the hashed gradient indices of the five simplex corners\n            var ii = i & 255;\n            var jj = j & 255;\n            var kk = k & 255;\n            var ll = l & 255;\n            var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\n            var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\n            var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\n            var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\n            var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\n            // Calculate the contribution from the five corners\n            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n            if (t0 < 0) n0 = 0.0;else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\n            }\n            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n            if (t1 < 0) n1 = 0.0;else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\n            }\n            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n            if (t2 < 0) n2 = 0.0;else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\n            }\n            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n            if (t3 < 0) n3 = 0.0;else {\n                t3 *= t3;\n                n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\n            }\n            var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n            if (t4 < 0) n4 = 0.0;else {\n                t4 *= t4;\n                n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\n            }\n            // Sum up and scale the result to cover the range [-1,1]\n            return 27.0 * (n0 + n1 + n2 + n3 + n4);\n        };\n\n        var THREEx = THREEx || {};\n\n        THREEx.Terrain = {};\n\n        /**\n         * allocate the heightmap\n         *\n         * @param  {Number} width the width of the heightmap\n         * @param  {Number} depth the depth of the heightmap\n         * @return {Array} the allocated heightmap\n         */\n        THREEx.Terrain.allocateHeightMap = function (width, depth) {\n            var ArrayClass = THREEx.Terrain.allocateHeightMap.ArrayClass;\n            var heightMap = new Array(width);\n            for (var x = 0; x < width; x++) {\n                heightMap[x] = new ArrayClass(depth);\n            }\n            return heightMap;\n        };\n        THREEx.Terrain.allocateHeightMap.ArrayClass = window.Float64Array || window.Array;\n\n        /**\n         * generate a heightmap using a simplex noise\n         * @todo make it it tunable... how ?\n         *\n         * @param  {Array} heightMap the heightmap to store the data\n         */\n        THREEx.Terrain.simplexHeightMap = function (heightMap) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            var simplex = new SimplexNoise();\n            for (var x = 0; x < width; x++) {\n                for (var z = 0; z < depth; z++) {\n                    // compute the height\n                    var height = 0;\n                    var level = 8;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.125;\n                    level *= 3;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.25;\n                    level *= 2;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 0.5;\n                    level *= 2;\n                    height += (simplex.noise(x / level, z / level) / 2 + 0.5) * 1;\n                    height /= 1 + 0.5 + 0.25 + 0.125;\n                    // put the height in the heightMap\n                    heightMap[x][z] = height;\n                }\n            }\n        };\n\n        /**\n         * build a canvas 2d from a heightmap\n         * @param  {Array} heightMap heightmap\n         * @param  {HTMLCanvasElement|undefined} canvas  the destination canvas.\n         * @return {HTMLCanvasElement}           the canvas\n         */\n        THREEx.Terrain.heightMapToCanvas = function (heightMap, canvas) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // create canvas\n            canvas = canvas || document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = depth;\n            var context = canvas.getContext(\"2d\");\n            // loop on each pixel of the canvas\n            for (var x = 0; x < canvas.width; x++) {\n                for (var y = 0; y < canvas.height; y++) {\n                    var height = heightMap[x][y];\n                    var color = THREEx.Terrain.heightToColor(height);\n                    context.fillStyle = color.getStyle();\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n            // return the just built canvas\n            return canvas;\n        };\n\n        /**\n         * Build a THREE.PlaneGeometry based on a heightMap\n         *\n         * @param  {Array} heightMap the heightmap\n         * @return {THREE.Geometry}  the just built geometry\n         */\n        THREEx.Terrain.heightMapToPlaneGeometry = function (heightMap) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // build geometry\n            var geometry = new THREEx.Terrain.PlaneGeometry(1, 1, width - 1, depth - 1);\n            // loop on each vertex of the geometry\n            for (var x = 0; x < width; x++) {\n                for (var z = 0; z < depth; z++) {\n                    // get the height from heightMap\n                    var height = heightMap[x][z];\n                    // set the vertex.z to a normalized height\n                    var vertex = geometry.vertices[x + z * width];\n                    vertex.z = (height - 0.5) * 2;\n                }\n            }\n            // notify the geometry need to update vertices\n            geometry.verticesNeedUpdate = true;\n            // notify the geometry need to update normals\n            geometry.computeFaceNormals();\n            geometry.computeVertexNormals();\n            geometry.normalsNeedUpdate = true;\n            // return the just built geometry\n            return geometry;\n        };\n\n        THREEx.Terrain.heightMapToHeight = function (heightMap, x, z) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // sanity check - boundaries\n            console.assert(x >= 0 && x < width);\n            console.assert(z >= 0 && z < depth);\n\n            // get the delta within a single segment\n            var deltaX = x - Math.floor(x);\n            var deltaZ = z - Math.floor(z);\n\n            // get the height of each corner of the segment\n            var heightNW = heightMap[Math.floor(x)][Math.floor(z)];\n            var heightNE = heightMap[Math.ceil(x)][Math.floor(z)];\n            var heightSW = heightMap[Math.floor(x)][Math.ceil(z)];\n            var heightSE = heightMap[Math.ceil(x)][Math.ceil(z)];\n\n            // test in which triangle the point is. north-east or south-west\n            var inTriangleNE = deltaX > deltaZ ? true : false;\n            if (inTriangleNE) {\n                var height = heightNE + (heightNW - heightNE) * (1 - deltaX) + (heightSE - heightNE) * deltaZ;\n            } else {\n                var height = heightSW + (heightSE - heightSW) * deltaX + (heightNW - heightSW) * (1 - deltaZ);\n            }\n            // return the height\n            return height;\n        };\n\n        THREEx.Terrain.planeToHeightMapCoords = function (heightMap, planeMesh, x, z) {\n\n            // TODO assert no rotation in planeMesh\n            // - how can i check that ? with euler ?\n\n            var position = new THREE.Vector3(x, 0, z);\n\n            // set position relative to planeMesh position\n            position.sub(planeMesh.position);\n\n            // heightMap origin is at its top-left, while planeMesh origin is at its center\n            position.x += planeMesh.geometry.width / 2 * planeMesh.scale.x;\n            position.z += planeMesh.geometry.height / 2 * planeMesh.scale.y;\n\n            // normalize it from [0,1] for the heightmap\n            position.x /= planeMesh.geometry.width * planeMesh.scale.x;\n            position.z /= planeMesh.geometry.height * planeMesh.scale.y;\n\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            // convert it in heightMap coordinate\n            position.x *= width - 1;\n            position.z *= depth - 1;\n\n            position.y = THREEx.Terrain.heightMapToHeight(heightMap, position.x, position.z);\n            position.y = (position.y - 0.5) * 2;\n            position.y *= planeMesh.scale.z;\n\n            return position.y;\n        };\n\n        THREEx.Terrain.planeToHeightMapCoords0 = function (position, heightMap, planeMesh) {\n\n            // TODO assert no rotation in planeMesh\n            // - how can i check that ? with euler ?\n\n            // set position relative to planeMesh position\n            position.sub(planeMesh.position);\n\n            // heightMap origin is at its top-left, while planeMesh origin is at its center\n            position.x += planeMesh.geometry.width / 2;\n            position.z += planeMesh.geometry.height / 2;\n\n            // normalize it from [0,1] for the heightmap\n            position.x /= planeMesh.geometry.width;\n            position.z /= planeMesh.geometry.height;\n\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n\n            // convert it in heightMap coordinate\n            position.x *= width - 1;\n            position.z *= depth - 1;\n\n            var height = THREEx.Terrain.heightMapToHeight(heightMap, position.x, position.z);\n            position.y = (height - 0.5) * 2;\n\n            return position;\n        };\n\n        /**\n         * Set the vertex color for a THREE.Geometry based on a heightMap\n         *\n         * @param  {Array} heightMap the heightmap\n         * @param  {THREE.Geometry} geometry  the geometry to set\n         */\n        THREEx.Terrain.heightMapToVertexColor = function (heightMap, geometry) {\n            // get heightMap dimensions\n            var width = heightMap.length;\n            var depth = heightMap[0].length;\n            // loop on each vertex of the geometry\n            var color = new THREE.Color();\n            for (var i = 0; i < geometry.faces.length; i++) {\n                var face = geometry.faces[i];\n                if (face instanceof THREE.Face4) {\n                    console.assert(face instanceof THREE.Face4);\n                    face.vertexColors.push(vertexIdxToColor(face.a).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.b).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.c).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.d).clone());\n                } else if (face instanceof THREE.Face3) {\n                    console.assert(face instanceof THREE.Face3);\n                    face.vertexColors.push(vertexIdxToColor(face.a).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.b).clone());\n                    face.vertexColors.push(vertexIdxToColor(face.c).clone());\n                } else console.assert(false);\n            }\n            geometry.colorsNeedUpdate = true;\n            return;\n\n            function vertexIdxToColor(vertexIdx) {\n                var x = Math.floor(vertexIdx % width);\n                var z = Math.floor(vertexIdx / width);\n                var height = heightMap[x][z];\n                return THREEx.Terrain.heightToColor(height);\n            }\n        };\n\n        /**\n         * give a color based on a given height\n         *\n         * @param {Number} height the height\n         * @return {THREE.Color} the color for this height\n         */\n        THREEx.Terrain.heightToColor = function () {\n            var color = new THREE.Color();\n            return function (height) {\n                // compute color based on height\n                if (height < 0.5) {\n                    height = height * 2 * 0.5 + 0.2;\n                    color.setRGB(0, 0, height);\n                } else if (height < 0.7) {\n                    height = (height - 0.5) / 0.2;\n                    height = height * 0.5 + 0.2;\n                    color.setRGB(0, height, 0);\n                } else {\n                    height = (height - 0.7) / 0.3;\n                    height = height * 0.5 + 0.5;\n                    color.setRGB(height, height, height);\n                }\n                // color.setRGB(1,1,1)\n                return color;\n            };\n        }();\n\n        //////////////////////////////////////////////////////////////////////////////////\n        //\t\tcomment\t\t\t\t\t\t\t\t//\n        //////////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * plane geometry with THREE.Face3 from three.js r66\n         *\n         * @param {[type]} width          [description]\n         * @param {[type]} height         [description]\n         * @param {[type]} widthSegments  [description]\n         * @param {[type]} heightSegments [description]\n         */\n        THREEx.Terrain.PlaneGeometry = function (width, height, widthSegments, heightSegments) {\n\n            THREE.Geometry.call(this);\n\n            this.width = width;\n            this.height = height;\n\n            this.widthSegments = widthSegments || 1;\n            this.heightSegments = heightSegments || 1;\n\n            var ix, iz;\n            var width_half = width / 2;\n            var height_half = height / 2;\n\n            var gridX = this.widthSegments;\n            var gridZ = this.heightSegments;\n\n            var gridX1 = gridX + 1;\n            var gridZ1 = gridZ + 1;\n\n            var segment_width = this.width / gridX;\n            var segment_height = this.height / gridZ;\n\n            var normal = new THREE.Vector3(0, 0, 1);\n\n            for (iz = 0; iz < gridZ1; iz++) {\n\n                for (ix = 0; ix < gridX1; ix++) {\n\n                    var x = ix * segment_width - width_half;\n                    var y = iz * segment_height - height_half;\n\n                    this.vertices.push(new THREE.Vector3(x, -y, 0));\n                }\n            }\n\n            for (iz = 0; iz < gridZ; iz++) {\n\n                for (ix = 0; ix < gridX; ix++) {\n\n                    var a = ix + gridX1 * iz;\n                    var b = ix + gridX1 * (iz + 1);\n                    var c = ix + 1 + gridX1 * (iz + 1);\n                    var d = ix + 1 + gridX1 * iz;\n\n                    var uva = new THREE.Vector2(ix / gridX, 1 - iz / gridZ);\n                    var uvb = new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ);\n                    var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);\n                    var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ);\n\n                    var face = new THREE.Face3(a, b, d);\n                    face.normal.copy(normal);\n                    face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n\n                    this.faces.push(face);\n                    this.faceVertexUvs[0].push([uva, uvb, uvd]);\n\n                    face = new THREE.Face3(b, c, d);\n                    face.normal.copy(normal);\n                    face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n\n                    this.faces.push(face);\n                    this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);\n                }\n            }\n\n            // this.computeCentroids();\n        };\n\n        THREEx.Terrain.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);\n\n        var renderer = new THREE.WebGLRenderer({\n            antialias: true,\n            canvas: document.querySelector(\"#canvas3\")\n        });\n        /* Fullscreen */\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        /* Append to HTML */\n        var onRenderFcts = [];\n        var scene = new THREE.Scene();\n        var camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.01, 1000);\n        /* Play around with camera positioning */\n        camera.position.z = 15;\n        camera.position.y = 2;\n        /* Fog provides depth to the landscape*/\n        scene.fog = new THREE.Fog(0x000, 0, 45);\n        (function () {\n            var light = new THREE.AmbientLight(0x202020);\n            scene.add(light);\n            var light = new THREE.DirectionalLight('white', 5);\n            light.position.set(0.5, 0.0, 2);\n            scene.add(light);\n            var light = new THREE.DirectionalLight('white', 0.75 * 2);\n            light.position.set(-0.5, -0.5, -2);\n            scene.add(light);\n        })();\n        var heightMap = THREEx.Terrain.allocateHeightMap(256, 256);\n        THREEx.Terrain.simplexHeightMap(heightMap);\n        var geometry = THREEx.Terrain.heightMapToPlaneGeometry(heightMap);\n        THREEx.Terrain.heightMapToVertexColor(heightMap, geometry);\n        /* Wireframe built-in color is white, no need to change that */\n        var material = new THREE.MeshBasicMaterial({\n            color: '#ffffff',\n            wireframe: true\n        });\n        var mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n        mesh.lookAt(new THREE.Vector3(0, 1, 0));\n        /* Play around with the scaling */\n        mesh.scale.y = 3.5;\n        mesh.scale.x = 3;\n        mesh.scale.z = 0.20;\n        mesh.scale.multiplyScalar(10);\n        /* Play around with the camera */\n        onRenderFcts.push(function (delta, now) {\n            mesh.rotation.z += 0.025 * delta;\n        });\n        onRenderFcts.push(function () {\n            renderer.render(scene, camera);\n        });\n        var lastTimeMsec = null;\n        window.animFrame = requestAnimationFrame(function animate(nowMsec) {\n            requestAnimationFrame(animate);\n            lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;\n            var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);\n            lastTimeMsec = nowMsec;\n            onRenderFcts.forEach(function (onRenderFct) {\n                onRenderFct(deltaMsec / 1000, nowMsec / 1000);\n            });\n        });\n    });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Zyb250ZW5kL2NvbXBvbmVudHMvcGxheS9MYW5kc2NhcGUuanM/NDEzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuY2xhc3MgTGFuZHNjYXBlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgY3JlYXRlTGFuZHNjYXBlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxjYW52YXMgaWQ9XCJjYW52YXMzXCIgLz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExhbmRzY2FwZTtcblxuZnVuY3Rpb24gY3JlYXRlTGFuZHNjYXBlKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgU2ltcGxleE5vaXNlID0gZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKHIgPT0gdW5kZWZpbmVkKSByID0gTWF0aDtcbiAgICAgICAgICAgIHRoaXMuZ3JhZDMgPSBbXG4gICAgICAgICAgICAgICAgWzEsIDEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgMSwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIC0xLCAwXSxcbiAgICAgICAgICAgICAgICBbLTEsIC0xLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgLTFdLFxuICAgICAgICAgICAgICAgIFstMSwgMCwgLTFdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAxXSxcbiAgICAgICAgICAgICAgICBbMCwgLTEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAtMV0sXG4gICAgICAgICAgICAgICAgWzAsIC0xLCAtMV1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHRoaXMuZ3JhZDQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAxLCAtMV0sXG4gICAgICAgICAgICAgICAgWzAsIDEsIC0xLCAxXSxcbiAgICAgICAgICAgICAgICBbMCwgMSwgLTEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMCwgLTEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAtMSwgMSwgLTFdLFxuICAgICAgICAgICAgICAgIFswLCAtMSwgLTEsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAtMSwgLTEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgMSwgMV0sXG4gICAgICAgICAgICAgICAgWzEsIDAsIDEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMSwgMCwgLTEsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAtMSwgLTFdLFxuICAgICAgICAgICAgICAgIFstMSwgMCwgMSwgMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAxLCAtMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAtMSwgMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAwLCAtMSwgLTFdLFxuICAgICAgICAgICAgICAgIFsxLCAxLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgMSwgMCwgLTFdLFxuICAgICAgICAgICAgICAgIFsxLCAtMSwgMCwgMV0sXG4gICAgICAgICAgICAgICAgWzEsIC0xLCAwLCAtMV0sXG4gICAgICAgICAgICAgICAgWy0xLCAxLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbLTEsIDEsIDAsIC0xXSxcbiAgICAgICAgICAgICAgICBbLTEsIC0xLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbLTEsIC0xLCAwLCAtMV0sXG4gICAgICAgICAgICAgICAgWzEsIDEsIDEsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAxLCAtMSwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIC0xLCAxLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgLTEsIC0xLCAwXSxcbiAgICAgICAgICAgICAgICBbLTEsIDEsIDEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgMSwgLTEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgLTEsIDEsIDBdLFxuICAgICAgICAgICAgICAgIFstMSwgLTEsIC0xLCAwXVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGhpcy5wID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wW2ldID0gTWF0aC5mbG9vcihyLnJhbmRvbSgpICogMjU2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvIHJlbW92ZSB0aGUgbmVlZCBmb3IgaW5kZXggd3JhcHBpbmcsIGRvdWJsZSB0aGUgcGVybXV0YXRpb24gdGFibGUgbGVuZ3RoXG4gICAgICAgICAgICB0aGlzLnBlcm0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcm1baV0gPSB0aGlzLnBbaSAmIDI1NV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgbG9va3VwIHRhYmxlIHRvIHRyYXZlcnNlIHRoZSBzaW1wbGV4IGFyb3VuZCBhIGdpdmVuIHBvaW50IGluIDRELlxuICAgICAgICAgICAgLy8gRGV0YWlscyBjYW4gYmUgZm91bmQgd2hlcmUgdGhpcyB0YWJsZSBpcyB1c2VkLCBpbiB0aGUgNEQgbm9pc2UgbWV0aG9kLlxuICAgICAgICAgICAgdGhpcy5zaW1wbGV4ID0gW1xuICAgICAgICAgICAgICAgIFswLCAxLCAyLCAzXSxcbiAgICAgICAgICAgICAgICBbMCwgMSwgMywgMl0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAyLCAzLCAxXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMSwgMiwgMywgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDIsIDEsIDNdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMywgMSwgMl0sXG4gICAgICAgICAgICAgICAgWzAsIDMsIDIsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAzLCAyLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsxLCAyLCAwLCAzXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIDMsIDAsIDJdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsyLCAzLCAwLCAxXSxcbiAgICAgICAgICAgICAgICBbMiwgMywgMSwgMF0sXG4gICAgICAgICAgICAgICAgWzEsIDAsIDIsIDNdLFxuICAgICAgICAgICAgICAgIFsxLCAwLCAzLCAyXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMiwgMCwgMywgMV0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsyLCAxLCAzLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFsyLCAwLCAxLCAzXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMywgMCwgMSwgMl0sXG4gICAgICAgICAgICAgICAgWzMsIDAsIDIsIDFdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMywgMSwgMiwgMF0sXG4gICAgICAgICAgICAgICAgWzIsIDEsIDAsIDNdLFxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIFszLCAxLCAwLCAyXSxcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgWzMsIDIsIDAsIDFdLFxuICAgICAgICAgICAgICAgIFszLCAyLCAxLCAwXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGcsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBnWzBdICogeCArIGdbMV0gKiB5O1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUuZG90MyA9IGZ1bmN0aW9uKGcsIHgsIHksIHopIHtcbiAgICAgICAgICAgIHJldHVybiBnWzBdICogeCArIGdbMV0gKiB5ICsgZ1syXSAqIHo7XG4gICAgICAgIH1cblxuICAgICAgICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlLmRvdDQgPSBmdW5jdGlvbihnLCB4LCB5LCB6LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gZ1swXSAqIHggKyBnWzFdICogeSArIGdbMl0gKiB6ICsgZ1szXSAqIHc7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2ltcGxleE5vaXNlLnByb3RvdHlwZS5ub2lzZSA9IGZ1bmN0aW9uKHhpbiwgeWluKSB7XG4gICAgICAgICAgICB2YXIgbjAsIG4xLCBuMjsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gICAgICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gICAgICAgICAgICB2YXIgRjIgPSAwLjUgKiAoTWF0aC5zcXJ0KDMuMCkgLSAxLjApO1xuICAgICAgICAgICAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG4gICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICAgICAgICB2YXIgRzIgPSAoMy4wIC0gTWF0aC5zcXJ0KDMuMCkpIC8gNi4wO1xuICAgICAgICAgICAgdmFyIHQgPSAoaSArIGopICogRzI7XG4gICAgICAgICAgICB2YXIgWDAgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXG4gICAgICAgICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgICAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgICAgICAgdmFyIHkwID0geWluIC0gWTA7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICAgICAgICAgICAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuICAgICAgICAgICAgaWYgKHgwID4geTApIHtcbiAgICAgICAgICAgICAgICBpMSA9IDE7XG4gICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgfSAvLyBsb3dlciB0cmlhbmdsZSwgWFkgb3JkZXI6ICgwLDApLT4oMSwwKS0+KDEsMSlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICAgICAgICBqMSA9IDE7XG4gICAgICAgICAgICB9IC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxuICAgICAgICAgICAgLy8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXG4gICAgICAgICAgICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAgICAgICAgICAgLy8gYyA9ICgzLXNxcnQoMykpLzZcbiAgICAgICAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgICAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgICAgICAgICAgIHZhciB4MiA9IHgwIC0gMS4wICsgMi4wICogRzI7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjtcbiAgICAgICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG4gICAgICAgICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgICAgICAgIHZhciBnaTAgPSB0aGlzLnBlcm1baWkgKyB0aGlzLnBlcm1bampdXSAlIDEyO1xuICAgICAgICAgICAgdmFyIGdpMSA9IHRoaXMucGVybVtpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajFdXSAlIDEyO1xuICAgICAgICAgICAgdmFyIGdpMiA9IHRoaXMucGVybVtpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxXV0gJSAxMjtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgICAgICAgIHZhciB0MCA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwO1xuICAgICAgICAgICAgaWYgKHQwIDwgMCkgbjAgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgICAgICAgICBuMCA9IHQwICogdDAgKiB0aGlzLmRvdCh0aGlzLmdyYWQzW2dpMF0sIHgwLCB5MCk7IC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDEgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcbiAgICAgICAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTFdLCB4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTI7XG4gICAgICAgICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQyICo9IHQyO1xuICAgICAgICAgICAgICAgIG4yID0gdDIgKiB0MiAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kyXSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cbiAgICAgICAgICAgIHJldHVybiA3MC4wICogKG4wICsgbjEgKyBuMik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gM0Qgc2ltcGxleCBub2lzZVxuICAgICAgICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlLm5vaXNlM2QgPSBmdW5jdGlvbih4aW4sIHlpbiwgemluKSB7XG4gICAgICAgICAgICB2YXIgbjAsIG4xLCBuMiwgbjM7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gICAgICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gICAgICAgICAgICB2YXIgRjMgPSAxLjAgLyAzLjA7XG4gICAgICAgICAgICB2YXIgcyA9ICh4aW4gKyB5aW4gKyB6aW4pICogRjM7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHNrZXcgZmFjdG9yIGZvciAzRFxuICAgICAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHlpbiArIHMpO1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHppbiArIHMpO1xuICAgICAgICAgICAgdmFyIEczID0gMS4wIC8gNi4wOyAvLyBWZXJ5IG5pY2UgYW5kIHNpbXBsZSB1bnNrZXcgZmFjdG9yLCB0b29cbiAgICAgICAgICAgIHZhciB0ID0gKGkgKyBqICsgaykgKiBHMztcbiAgICAgICAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6KSBzcGFjZVxuICAgICAgICAgICAgdmFyIFkwID0gaiAtIHQ7XG4gICAgICAgICAgICB2YXIgWjAgPSBrIC0gdDtcbiAgICAgICAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5LHogZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgICAgICAgIHZhciB6MCA9IHppbiAtIFowO1xuICAgICAgICAgICAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgICAgICAgICAgIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgICAgICAgIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgICAgICAgaWYgKHgwID49IHkwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkwID49IHowKSB7XG4gICAgICAgICAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgajIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBrMiA9IDA7XG4gICAgICAgICAgICAgICAgfSAvLyBYIFkgWiBvcmRlclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICAgICAgICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgajEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgajIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBrMiA9IDE7XG4gICAgICAgICAgICAgICAgfSAvLyBYIFogWSBvcmRlclxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgazEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGoyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgazIgPSAxO1xuICAgICAgICAgICAgICAgIH0gLy8gWiBYIFkgb3JkZXJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHgwPHkwXG4gICAgICAgICAgICAgICAgaWYgKHkwIDwgejApIHtcbiAgICAgICAgICAgICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGsxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgICAgICAgICB9IC8vIFogWSBYIG9yZGVyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDAgPCB6MCkge1xuICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgazEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGoyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgazIgPSAxO1xuICAgICAgICAgICAgICAgIH0gLy8gWSBaIFggb3JkZXJcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBqMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgICAgICAgICB9IC8vIFkgWCBaIG9yZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAgICAgICAgICAgLy8gYSBzdGVwIG9mICgwLDEsMCkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLDEtYywtYykgaW4gKHgseSx6KSwgYW5kXG4gICAgICAgICAgICAvLyBhIHN0ZXAgb2YgKDAsMCwxKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsLWMsMS1jKSBpbiAoeCx5LHopLCB3aGVyZVxuICAgICAgICAgICAgLy8gYyA9IDEvNi5cbiAgICAgICAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMzsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHkxID0geTAgLSBqMSArIEczO1xuICAgICAgICAgICAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICAgICAgICAgICAgdmFyIHgyID0geDAgLSBpMiArIDIuMCAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgICAgICAgIHZhciB5MiA9IHkwIC0gajIgKyAyLjAgKiBHMztcbiAgICAgICAgICAgIHZhciB6MiA9IHowIC0gazIgKyAyLjAgKiBHMztcbiAgICAgICAgICAgIHZhciB4MyA9IHgwIC0gMS4wICsgMy4wICogRzM7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTMgPSB5MCAtIDEuMCArIDMuMCAqIEczO1xuICAgICAgICAgICAgdmFyIHozID0gejAgLSAxLjAgKyAzLjAgKiBHMztcbiAgICAgICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZm91ciBzaW1wbGV4IGNvcm5lcnNcbiAgICAgICAgICAgIHZhciBpaSA9IGkgJiAyNTU7XG4gICAgICAgICAgICB2YXIgamogPSBqICYgMjU1O1xuICAgICAgICAgICAgdmFyIGtrID0gayAmIDI1NTtcbiAgICAgICAgICAgIHZhciBnaTAgPSB0aGlzLnBlcm1baWkgKyB0aGlzLnBlcm1bamogKyB0aGlzLnBlcm1ba2tdXV0gJSAxMjtcbiAgICAgICAgICAgIHZhciBnaTEgPSB0aGlzLnBlcm1baWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxICsgdGhpcy5wZXJtW2trICsgazFdXV0gJSAxMjtcbiAgICAgICAgICAgIHZhciBnaTIgPSB0aGlzLnBlcm1baWkgKyBpMiArIHRoaXMucGVybVtqaiArIGoyICsgdGhpcy5wZXJtW2trICsgazJdXV0gJSAxMjtcbiAgICAgICAgICAgIHZhciBnaTMgPSB0aGlzLnBlcm1baWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMSArIHRoaXMucGVybVtrayArIDFdXV0gJSAxMjtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgICAgICAgICAgdmFyIHQwID0gMC42IC0geDAgKiB4MCAtIHkwICogeTAgLSB6MCAqIHowO1xuICAgICAgICAgICAgaWYgKHQwIDwgMCkgbjAgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgICAgICAgICBuMCA9IHQwICogdDAgKiB0aGlzLmRvdDModGhpcy5ncmFkM1tnaTBdLCB4MCwgeTAsIHowKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcbiAgICAgICAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogdGhpcy5kb3QzKHRoaXMuZ3JhZDNbZ2kxXSwgeDEsIHkxLCB6MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XG4gICAgICAgICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQyICo9IHQyO1xuICAgICAgICAgICAgICAgIG4yID0gdDIgKiB0MiAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpMl0sIHgyLCB5MiwgejIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQzID0gMC42IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozO1xuICAgICAgICAgICAgaWYgKHQzIDwgMCkgbjMgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MyAqPSB0MztcbiAgICAgICAgICAgICAgICBuMyA9IHQzICogdDMgKiB0aGlzLmRvdDModGhpcy5ncmFkM1tnaTNdLCB4MywgeTMsIHozKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0xLDFdXG4gICAgICAgICAgICByZXR1cm4gMzIuMCAqIChuMCArIG4xICsgbjIgKyBuMyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gNEQgc2ltcGxleCBub2lzZVxuICAgICAgICBTaW1wbGV4Tm9pc2UucHJvdG90eXBlLm5vaXNlNGQgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgICAgICAgICAvLyBGb3IgZmFzdGVyIGFuZCBlYXNpZXIgbG9va3Vwc1xuICAgICAgICAgICAgdmFyIGdyYWQ0ID0gdGhpcy5ncmFkNDtcbiAgICAgICAgICAgIHZhciBzaW1wbGV4ID0gdGhpcy5zaW1wbGV4O1xuICAgICAgICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG5cbiAgICAgICAgICAgIC8vIFRoZSBza2V3aW5nIGFuZCB1bnNrZXdpbmcgZmFjdG9ycyBhcmUgaGFpcnkgYWdhaW4gZm9yIHRoZSA0RCBjYXNlXG4gICAgICAgICAgICB2YXIgRjQgPSAoTWF0aC5zcXJ0KDUuMCkgLSAxLjApIC8gNC4wO1xuICAgICAgICAgICAgdmFyIEc0ID0gKDUuMCAtIE1hdGguc3FydCg1LjApKSAvIDIwLjA7XG4gICAgICAgICAgICB2YXIgbjAsIG4xLCBuMiwgbjMsIG40OyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZpdmUgY29ybmVyc1xuICAgICAgICAgICAgLy8gU2tldyB0aGUgKHgseSx6LHcpIHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBjZWxsIG9mIDI0IHNpbXBsaWNlcyB3ZSdyZSBpblxuICAgICAgICAgICAgdmFyIHMgPSAoeCArIHkgKyB6ICsgdykgKiBGNDsgLy8gRmFjdG9yIGZvciA0RCBza2V3aW5nXG4gICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeCArIHMpO1xuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKHkgKyBzKTtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcih6ICsgcyk7XG4gICAgICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3IodyArIHMpO1xuICAgICAgICAgICAgdmFyIHQgPSAoaSArIGogKyBrICsgbCkgKiBHNDsgLy8gRmFjdG9yIGZvciA0RCB1bnNrZXdpbmdcbiAgICAgICAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXG4gICAgICAgICAgICB2YXIgWTAgPSBqIC0gdDtcbiAgICAgICAgICAgIHZhciBaMCA9IGsgLSB0O1xuICAgICAgICAgICAgdmFyIFcwID0gbCAtIHQ7XG4gICAgICAgICAgICB2YXIgeDAgPSB4IC0gWDA7IC8vIFRoZSB4LHkseix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICAgICAgICAgICAgdmFyIHkwID0geSAtIFkwO1xuICAgICAgICAgICAgdmFyIHowID0geiAtIFowO1xuICAgICAgICAgICAgdmFyIHcwID0gdyAtIFcwO1xuXG4gICAgICAgICAgICAvLyBGb3IgdGhlIDREIGNhc2UsIHRoZSBzaW1wbGV4IGlzIGEgNEQgc2hhcGUgSSB3b24ndCBldmVuIHRyeSB0byBkZXNjcmliZS5cbiAgICAgICAgICAgIC8vIFRvIGZpbmQgb3V0IHdoaWNoIG9mIHRoZSAyNCBwb3NzaWJsZSBzaW1wbGljZXMgd2UncmUgaW4sIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLlxuICAgICAgICAgICAgLy8gVGhlIG1ldGhvZCBiZWxvdyBpcyBhIGdvb2Qgd2F5IG9mIGZpbmRpbmcgdGhlIG9yZGVyaW5nIG9mIHgseSx6LHcgYW5kXG4gICAgICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIGNvcnJlY3QgdHJhdmVyc2FsIG9yZGVyIGZvciB0aGUgc2ltcGxleCB3ZeKAmXJlIGluLlxuICAgICAgICAgICAgLy8gRmlyc3QsIHNpeCBwYWlyLXdpc2UgY29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVhY2ggcG9zc2libGUgcGFpclxuICAgICAgICAgICAgLy8gb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byBhZGQgdXAgYmluYXJ5IGJpdHNcbiAgICAgICAgICAgIC8vIGZvciBhbiBpbnRlZ2VyIGluZGV4LlxuICAgICAgICAgICAgdmFyIGMxID0gKHgwID4geTApID8gMzIgOiAwO1xuICAgICAgICAgICAgdmFyIGMyID0gKHgwID4gejApID8gMTYgOiAwO1xuICAgICAgICAgICAgdmFyIGMzID0gKHkwID4gejApID8gOCA6IDA7XG4gICAgICAgICAgICB2YXIgYzQgPSAoeDAgPiB3MCkgPyA0IDogMDtcbiAgICAgICAgICAgIHZhciBjNSA9ICh5MCA+IHcwKSA/IDIgOiAwO1xuICAgICAgICAgICAgdmFyIGM2ID0gKHowID4gdzApID8gMSA6IDA7XG4gICAgICAgICAgICB2YXIgYyA9IGMxICsgYzIgKyBjMyArIGM0ICsgYzUgKyBjNjtcbiAgICAgICAgICAgIHZhciBpMSwgajEsIGsxLCBsMTsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIHNlY29uZCBzaW1wbGV4IGNvcm5lclxuICAgICAgICAgICAgdmFyIGkyLCBqMiwgazIsIGwyOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgdGhpcmQgc2ltcGxleCBjb3JuZXJcbiAgICAgICAgICAgIHZhciBpMywgajMsIGszLCBsMzsgLy8gVGhlIGludGVnZXIgb2Zmc2V0cyBmb3IgdGhlIGZvdXJ0aCBzaW1wbGV4IGNvcm5lclxuICAgICAgICAgICAgLy8gc2ltcGxleFtjXSBpcyBhIDQtdmVjdG9yIHdpdGggdGhlIG51bWJlcnMgMCwgMSwgMiBhbmQgMyBpbiBzb21lIG9yZGVyLlxuICAgICAgICAgICAgLy8gTWFueSB2YWx1ZXMgb2YgYyB3aWxsIG5ldmVyIG9jY3VyLCBzaW5jZSBlLmcuIHg+eT56PncgbWFrZXMgeDx6LCB5PHcgYW5kIHg8d1xuICAgICAgICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXG4gICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJlc2hvbGRpbmcgdG8gc2V0IHRoZSBjb29yZGluYXRlcyBpbiB0dXJuIGZyb20gdGhlIGxhcmdlc3QgbWFnbml0dWRlLlxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciAzIGluIHRoZSBcInNpbXBsZXhcIiBhcnJheSBpcyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIGxhcmdlc3QgY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIGkxID0gc2ltcGxleFtjXVswXSA+PSAzID8gMSA6IDA7XG4gICAgICAgICAgICBqMSA9IHNpbXBsZXhbY11bMV0gPj0gMyA/IDEgOiAwO1xuICAgICAgICAgICAgazEgPSBzaW1wbGV4W2NdWzJdID49IDMgPyAxIDogMDtcbiAgICAgICAgICAgIGwxID0gc2ltcGxleFtjXVszXSA+PSAzID8gMSA6IDA7XG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIDIgaW4gdGhlIFwic2ltcGxleFwiIGFycmF5IGlzIGF0IHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgICAgICAgaTIgPSBzaW1wbGV4W2NdWzBdID49IDIgPyAxIDogMDtcbiAgICAgICAgICAgIGoyID0gc2ltcGxleFtjXVsxXSA+PSAyID8gMSA6IDA7XG4gICAgICAgICAgICBrMiA9IHNpbXBsZXhbY11bMl0gPj0gMiA/IDEgOiAwO1xuICAgICAgICAgICAgbDIgPSBzaW1wbGV4W2NdWzNdID49IDIgPyAxIDogMDtcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgMSBpbiB0aGUgXCJzaW1wbGV4XCIgYXJyYXkgaXMgYXQgdGhlIHNlY29uZCBzbWFsbGVzdCBjb29yZGluYXRlLlxuICAgICAgICAgICAgaTMgPSBzaW1wbGV4W2NdWzBdID49IDEgPyAxIDogMDtcbiAgICAgICAgICAgIGozID0gc2ltcGxleFtjXVsxXSA+PSAxID8gMSA6IDA7XG4gICAgICAgICAgICBrMyA9IHNpbXBsZXhbY11bMl0gPj0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgbDMgPSBzaW1wbGV4W2NdWzNdID49IDEgPyAxIDogMDtcbiAgICAgICAgICAgIC8vIFRoZSBmaWZ0aCBjb3JuZXIgaGFzIGFsbCBjb29yZGluYXRlIG9mZnNldHMgPSAxLCBzbyBubyBuZWVkIHRvIGxvb2sgdGhhdCB1cC5cbiAgICAgICAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHNDsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzQ7XG4gICAgICAgICAgICB2YXIgejEgPSB6MCAtIGsxICsgRzQ7XG4gICAgICAgICAgICB2YXIgdzEgPSB3MCAtIGwxICsgRzQ7XG4gICAgICAgICAgICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wICogRzQ7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgICAgICB2YXIgeTIgPSB5MCAtIGoyICsgMi4wICogRzQ7XG4gICAgICAgICAgICB2YXIgejIgPSB6MCAtIGsyICsgMi4wICogRzQ7XG4gICAgICAgICAgICB2YXIgdzIgPSB3MCAtIGwyICsgMi4wICogRzQ7XG4gICAgICAgICAgICB2YXIgeDMgPSB4MCAtIGkzICsgMy4wICogRzQ7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHkzID0geTAgLSBqMyArIDMuMCAqIEc0O1xuICAgICAgICAgICAgdmFyIHozID0gejAgLSBrMyArIDMuMCAqIEc0O1xuICAgICAgICAgICAgdmFyIHczID0gdzAgLSBsMyArIDMuMCAqIEc0O1xuICAgICAgICAgICAgdmFyIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBHNDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgICAgICAgdmFyIHk0ID0geTAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgICAgICAgIHZhciB6NCA9IHowIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICAgICAgICB2YXIgdzQgPSB3MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmaXZlIHNpbXBsZXggY29ybmVyc1xuICAgICAgICAgICAgdmFyIGlpID0gaSAmIDI1NTtcbiAgICAgICAgICAgIHZhciBqaiA9IGogJiAyNTU7XG4gICAgICAgICAgICB2YXIga2sgPSBrICYgMjU1O1xuICAgICAgICAgICAgdmFyIGxsID0gbCAmIDI1NTtcbiAgICAgICAgICAgIHZhciBnaTAgPSBwZXJtW2lpICsgcGVybVtqaiArIHBlcm1ba2sgKyBwZXJtW2xsXV1dXSAlIDMyO1xuICAgICAgICAgICAgdmFyIGdpMSA9IHBlcm1baWkgKyBpMSArIHBlcm1bamogKyBqMSArIHBlcm1ba2sgKyBrMSArIHBlcm1bbGwgKyBsMV1dXV0gJSAzMjtcbiAgICAgICAgICAgIHZhciBnaTIgPSBwZXJtW2lpICsgaTIgKyBwZXJtW2pqICsgajIgKyBwZXJtW2trICsgazIgKyBwZXJtW2xsICsgbDJdXV1dICUgMzI7XG4gICAgICAgICAgICB2YXIgZ2kzID0gcGVybVtpaSArIGkzICsgcGVybVtqaiArIGozICsgcGVybVtrayArIGszICsgcGVybVtsbCArIGwzXV1dXSAlIDMyO1xuICAgICAgICAgICAgdmFyIGdpNCA9IHBlcm1baWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMSArIHBlcm1bbGwgKyAxXV1dXSAlIDMyO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAgICAgICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejAgLSB3MCAqIHcwO1xuICAgICAgICAgICAgaWYgKHQwIDwgMCkgbjAgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MCAqPSB0MDtcbiAgICAgICAgICAgICAgICBuMCA9IHQwICogdDAgKiB0aGlzLmRvdDQoZ3JhZDRbZ2kwXSwgeDAsIHkwLCB6MCwgdzApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxIC0gdzEgKiB3MTtcbiAgICAgICAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgICAgICAgICAgbjEgPSB0MSAqIHQxICogdGhpcy5kb3Q0KGdyYWQ0W2dpMV0sIHgxLCB5MSwgejEsIHcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MiA9IDAuNiAtIHgyICogeDIgLSB5MiAqIHkyIC0gejIgKiB6MiAtIHcyICogdzI7XG4gICAgICAgICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQyICo9IHQyO1xuICAgICAgICAgICAgICAgIG4yID0gdDIgKiB0MiAqIHRoaXMuZG90NChncmFkNFtnaTJdLCB4MiwgeTIsIHoyLCB3Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejMgLSB3MyAqIHczO1xuICAgICAgICAgICAgaWYgKHQzIDwgMCkgbjMgPSAwLjA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0MyAqPSB0MztcbiAgICAgICAgICAgICAgICBuMyA9IHQzICogdDMgKiB0aGlzLmRvdDQoZ3JhZDRbZ2kzXSwgeDMsIHkzLCB6MywgdzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQ0ID0gMC42IC0geDQgKiB4NCAtIHk0ICogeTQgLSB6NCAqIHo0IC0gdzQgKiB3NDtcbiAgICAgICAgICAgIGlmICh0NCA8IDApIG40ID0gMC4wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdDQgKj0gdDQ7XG4gICAgICAgICAgICAgICAgbjQgPSB0NCAqIHQ0ICogdGhpcy5kb3Q0KGdyYWQ0W2dpNF0sIHg0LCB5NCwgejQsIHc0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN1bSB1cCBhbmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdXG4gICAgICAgICAgICByZXR1cm4gMjcuMCAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgVEhSRUV4ID0gVEhSRUV4IHx8IHt9XG5cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4gPSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbGxvY2F0ZSB0aGUgaGVpZ2h0bWFwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggdGhlIHdpZHRoIG9mIHRoZSBoZWlnaHRtYXBcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBkZXB0aCB0aGUgZGVwdGggb2YgdGhlIGhlaWdodG1hcFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIGFsbG9jYXRlZCBoZWlnaHRtYXBcbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmFsbG9jYXRlSGVpZ2h0TWFwID0gZnVuY3Rpb24od2lkdGgsIGRlcHRoKSB7XG4gICAgICAgICAgICB2YXIgQXJyYXlDbGFzcyA9IFRIUkVFeC5UZXJyYWluLmFsbG9jYXRlSGVpZ2h0TWFwLkFycmF5Q2xhc3NcbiAgICAgICAgICAgIHZhciBoZWlnaHRNYXAgPSBuZXcgQXJyYXkod2lkdGgpXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRNYXBbeF0gPSBuZXcgQXJyYXlDbGFzcyhkZXB0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWlnaHRNYXBcbiAgICAgICAgfVxuICAgICAgICBUSFJFRXguVGVycmFpbi5hbGxvY2F0ZUhlaWdodE1hcC5BcnJheUNsYXNzID0gd2luZG93LkZsb2F0NjRBcnJheSB8fCB3aW5kb3cuQXJyYXlcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2VuZXJhdGUgYSBoZWlnaHRtYXAgdXNpbmcgYSBzaW1wbGV4IG5vaXNlXG4gICAgICAgICAqIEB0b2RvIG1ha2UgaXQgaXQgdHVuYWJsZS4uLiBob3cgP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gaGVpZ2h0TWFwIHRoZSBoZWlnaHRtYXAgdG8gc3RvcmUgdGhlIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLnNpbXBsZXhIZWlnaHRNYXAgPSBmdW5jdGlvbihoZWlnaHRNYXApIHtcbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuXG4gICAgICAgICAgICB2YXIgc2ltcGxleCA9IG5ldyBTaW1wbGV4Tm9pc2UoKVxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSA4XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSAoc2ltcGxleC5ub2lzZSh4IC8gbGV2ZWwsIHogLyBsZXZlbCkgLyAyICsgMC41KSAqIDAuMTI1XG4gICAgICAgICAgICAgICAgICAgIGxldmVsICo9IDNcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IChzaW1wbGV4Lm5vaXNlKHggLyBsZXZlbCwgeiAvIGxldmVsKSAvIDIgKyAwLjUpICogMC4yNVxuICAgICAgICAgICAgICAgICAgICBsZXZlbCAqPSAyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSAoc2ltcGxleC5ub2lzZSh4IC8gbGV2ZWwsIHogLyBsZXZlbCkgLyAyICsgMC41KSAqIDAuNVxuICAgICAgICAgICAgICAgICAgICBsZXZlbCAqPSAyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSAoc2ltcGxleC5ub2lzZSh4IC8gbGV2ZWwsIHogLyBsZXZlbCkgLyAyICsgMC41KSAqIDFcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC89IDEgKyAwLjUgKyAwLjI1ICsgMC4xMjVcbiAgICAgICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBoZWlnaHQgaW4gdGhlIGhlaWdodE1hcFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHRNYXBbeF1bel0gPSBoZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYnVpbGQgYSBjYW52YXMgMmQgZnJvbSBhIGhlaWdodG1hcFxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gaGVpZ2h0TWFwIGhlaWdodG1hcFxuICAgICAgICAgKiBAcGFyYW0gIHtIVE1MQ2FudmFzRWxlbWVudHx1bmRlZmluZWR9IGNhbnZhcyAgdGhlIGRlc3RpbmF0aW9uIGNhbnZhcy5cbiAgICAgICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9ICAgICAgICAgICB0aGUgY2FudmFzXG4gICAgICAgICAqL1xuICAgICAgICBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb0NhbnZhcyA9IGZ1bmN0aW9uKGhlaWdodE1hcCwgY2FudmFzKSB7XG4gICAgICAgICAgICAvLyBnZXQgaGVpZ2h0TWFwIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodE1hcC5sZW5ndGhcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGhlaWdodE1hcFswXS5sZW5ndGhcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjYW52YXNcbiAgICAgICAgICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkZXB0aFxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgLy8gbG9vcCBvbiBlYWNoIHBpeGVsIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0TWFwW3hdW3ldXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IFRIUkVFeC5UZXJyYWluLmhlaWdodFRvQ29sb3IoaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLmdldFN0eWxlKClcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCAxLCAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUganVzdCBidWlsdCBjYW52YXNcbiAgICAgICAgICAgIHJldHVybiBjYW52YXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBhIFRIUkVFLlBsYW5lR2VvbWV0cnkgYmFzZWQgb24gYSBoZWlnaHRNYXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXl9IGhlaWdodE1hcCB0aGUgaGVpZ2h0bWFwXG4gICAgICAgICAqIEByZXR1cm4ge1RIUkVFLkdlb21ldHJ5fSAgdGhlIGp1c3QgYnVpbHQgZ2VvbWV0cnlcbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmhlaWdodE1hcFRvUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uKGhlaWdodE1hcCkge1xuICAgICAgICAgICAgLy8gZ2V0IGhlaWdodE1hcCBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBoZWlnaHRNYXAubGVuZ3RoXG4gICAgICAgICAgICB2YXIgZGVwdGggPSBoZWlnaHRNYXBbMF0ubGVuZ3RoXG4gICAgICAgICAgICAvLyBidWlsZCBnZW9tZXRyeVxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFeC5UZXJyYWluLlBsYW5lR2VvbWV0cnkoMSwgMSwgd2lkdGggLSAxLCBkZXB0aCAtIDEpXG4gICAgICAgICAgICAvLyBsb29wIG9uIGVhY2ggdmVydGV4IG9mIHRoZSBnZW9tZXRyeVxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaGVpZ2h0IGZyb20gaGVpZ2h0TWFwXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHRNYXBbeF1bel1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB2ZXJ0ZXgueiB0byBhIG5vcm1hbGl6ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBnZW9tZXRyeS52ZXJ0aWNlc1t4ICsgeiAqIHdpZHRoXVxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgueiA9IChoZWlnaHQgLSAwLjUpICogMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdGlmeSB0aGUgZ2VvbWV0cnkgbmVlZCB0byB1cGRhdGUgdmVydGljZXNcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgIC8vIG5vdGlmeSB0aGUgZ2VvbWV0cnkgbmVlZCB0byB1cGRhdGUgbm9ybWFsc1xuICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKClcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKClcbiAgICAgICAgICAgIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBqdXN0IGJ1aWx0IGdlb21ldHJ5XG4gICAgICAgICAgICByZXR1cm4gZ2VvbWV0cnlcbiAgICAgICAgfVxuXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmhlaWdodE1hcFRvSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0TWFwLCB4LCB6KSB7XG4gICAgICAgICAgICAvLyBnZXQgaGVpZ2h0TWFwIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodE1hcC5sZW5ndGhcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGhlaWdodE1hcFswXS5sZW5ndGhcbiAgICAgICAgICAgIC8vIHNhbml0eSBjaGVjayAtIGJvdW5kYXJpZXNcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHggPj0gMCAmJiB4IDwgd2lkdGgpXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh6ID49IDAgJiYgeiA8IGRlcHRoKVxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRlbHRhIHdpdGhpbiBhIHNpbmdsZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgZGVsdGFYID0geCAtIE1hdGguZmxvb3IoeClcbiAgICAgICAgICAgIHZhciBkZWx0YVogPSB6IC0gTWF0aC5mbG9vcih6KVxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGhlaWdodCBvZiBlYWNoIGNvcm5lciBvZiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgdmFyIGhlaWdodE5XID0gaGVpZ2h0TWFwW01hdGguZmxvb3IoeCldW01hdGguZmxvb3IoeildXG4gICAgICAgICAgICB2YXIgaGVpZ2h0TkUgPSBoZWlnaHRNYXBbTWF0aC5jZWlsKHgpXVtNYXRoLmZsb29yKHopXVxuICAgICAgICAgICAgdmFyIGhlaWdodFNXID0gaGVpZ2h0TWFwW01hdGguZmxvb3IoeCldW01hdGguY2VpbCh6KV1cbiAgICAgICAgICAgIHZhciBoZWlnaHRTRSA9IGhlaWdodE1hcFtNYXRoLmNlaWwoeCldW01hdGguY2VpbCh6KV1cblxuICAgICAgICAgICAgLy8gdGVzdCBpbiB3aGljaCB0cmlhbmdsZSB0aGUgcG9pbnQgaXMuIG5vcnRoLWVhc3Qgb3Igc291dGgtd2VzdFxuICAgICAgICAgICAgdmFyIGluVHJpYW5nbGVORSA9IGRlbHRhWCA+IGRlbHRhWiA/IHRydWUgOiBmYWxzZVxuICAgICAgICAgICAgaWYgKGluVHJpYW5nbGVORSkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHRORSArXG4gICAgICAgICAgICAgICAgICAgIChoZWlnaHROVyAtIGhlaWdodE5FKSAqICgxIC0gZGVsdGFYKSArXG4gICAgICAgICAgICAgICAgICAgIChoZWlnaHRTRSAtIGhlaWdodE5FKSAqIGRlbHRhWlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0U1cgK1xuICAgICAgICAgICAgICAgICAgICAoaGVpZ2h0U0UgLSBoZWlnaHRTVykgKiBkZWx0YVggK1xuICAgICAgICAgICAgICAgICAgICAoaGVpZ2h0TlcgLSBoZWlnaHRTVykgKiAoMSAtIGRlbHRhWilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgaGVpZ2h0XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBUSFJFRXguVGVycmFpbi5wbGFuZVRvSGVpZ2h0TWFwQ29vcmRzID0gZnVuY3Rpb24oaGVpZ2h0TWFwLCBwbGFuZU1lc2gsIHgsIHopIHtcblxuICAgICAgICAgICAgLy8gVE9ETyBhc3NlcnQgbm8gcm90YXRpb24gaW4gcGxhbmVNZXNoXG4gICAgICAgICAgICAvLyAtIGhvdyBjYW4gaSBjaGVjayB0aGF0ID8gd2l0aCBldWxlciA/XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKHgsIDAsIHopXG5cbiAgICAgICAgICAgIC8vIHNldCBwb3NpdGlvbiByZWxhdGl2ZSB0byBwbGFuZU1lc2ggcG9zaXRpb25cbiAgICAgICAgICAgIHBvc2l0aW9uLnN1YihwbGFuZU1lc2gucG9zaXRpb24pXG5cbiAgICAgICAgICAgIC8vIGhlaWdodE1hcCBvcmlnaW4gaXMgYXQgaXRzIHRvcC1sZWZ0LCB3aGlsZSBwbGFuZU1lc2ggb3JpZ2luIGlzIGF0IGl0cyBjZW50ZXJcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gcGxhbmVNZXNoLmdlb21ldHJ5LndpZHRoIC8gMiAqIHBsYW5lTWVzaC5zY2FsZS54XG4gICAgICAgICAgICBwb3NpdGlvbi56ICs9IHBsYW5lTWVzaC5nZW9tZXRyeS5oZWlnaHQgLyAyICogcGxhbmVNZXNoLnNjYWxlLnlcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGl0IGZyb20gWzAsMV0gZm9yIHRoZSBoZWlnaHRtYXBcbiAgICAgICAgICAgIHBvc2l0aW9uLnggLz0gcGxhbmVNZXNoLmdlb21ldHJ5LndpZHRoICogcGxhbmVNZXNoLnNjYWxlLnhcbiAgICAgICAgICAgIHBvc2l0aW9uLnogLz0gcGxhbmVNZXNoLmdlb21ldHJ5LmhlaWdodCAqIHBsYW5lTWVzaC5zY2FsZS55XG5cbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGl0IGluIGhlaWdodE1hcCBjb29yZGluYXRlXG4gICAgICAgICAgICBwb3NpdGlvbi54ICo9ICh3aWR0aCAtIDEpXG4gICAgICAgICAgICBwb3NpdGlvbi56ICo9IChkZXB0aCAtIDEpXG5cbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBUSFJFRXguVGVycmFpbi5oZWlnaHRNYXBUb0hlaWdodChoZWlnaHRNYXAsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnopXG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gKHBvc2l0aW9uLnkgLSAwLjUpICogMlxuICAgICAgICAgICAgcG9zaXRpb24ueSAqPSBwbGFuZU1lc2guc2NhbGUuelxuXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24ueVxuICAgICAgICB9XG5cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4ucGxhbmVUb0hlaWdodE1hcENvb3JkczAgPSBmdW5jdGlvbihwb3NpdGlvbiwgaGVpZ2h0TWFwLCBwbGFuZU1lc2gpIHtcblxuICAgICAgICAgICAgLy8gVE9ETyBhc3NlcnQgbm8gcm90YXRpb24gaW4gcGxhbmVNZXNoXG4gICAgICAgICAgICAvLyAtIGhvdyBjYW4gaSBjaGVjayB0aGF0ID8gd2l0aCBldWxlciA/XG5cbiAgICAgICAgICAgIC8vIHNldCBwb3NpdGlvbiByZWxhdGl2ZSB0byBwbGFuZU1lc2ggcG9zaXRpb25cbiAgICAgICAgICAgIHBvc2l0aW9uLnN1YihwbGFuZU1lc2gucG9zaXRpb24pXG5cbiAgICAgICAgICAgIC8vIGhlaWdodE1hcCBvcmlnaW4gaXMgYXQgaXRzIHRvcC1sZWZ0LCB3aGlsZSBwbGFuZU1lc2ggb3JpZ2luIGlzIGF0IGl0cyBjZW50ZXJcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gcGxhbmVNZXNoLmdlb21ldHJ5LndpZHRoIC8gMlxuICAgICAgICAgICAgcG9zaXRpb24ueiArPSBwbGFuZU1lc2guZ2VvbWV0cnkuaGVpZ2h0IC8gMlxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgaXQgZnJvbSBbMCwxXSBmb3IgdGhlIGhlaWdodG1hcFxuICAgICAgICAgICAgcG9zaXRpb24ueCAvPSBwbGFuZU1lc2guZ2VvbWV0cnkud2lkdGhcbiAgICAgICAgICAgIHBvc2l0aW9uLnogLz0gcGxhbmVNZXNoLmdlb21ldHJ5LmhlaWdodFxuXG4gICAgICAgICAgICAvLyBnZXQgaGVpZ2h0TWFwIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodE1hcC5sZW5ndGhcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGhlaWdodE1hcFswXS5sZW5ndGhcblxuICAgICAgICAgICAgLy8gY29udmVydCBpdCBpbiBoZWlnaHRNYXAgY29vcmRpbmF0ZVxuICAgICAgICAgICAgcG9zaXRpb24ueCAqPSAod2lkdGggLSAxKVxuICAgICAgICAgICAgcG9zaXRpb24ueiAqPSAoZGVwdGggLSAxKVxuXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9IZWlnaHQoaGVpZ2h0TWFwLCBwb3NpdGlvbi54LCBwb3NpdGlvbi56KVxuICAgICAgICAgICAgcG9zaXRpb24ueSA9IChoZWlnaHQgLSAwLjUpICogMlxuXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB2ZXJ0ZXggY29sb3IgZm9yIGEgVEhSRUUuR2VvbWV0cnkgYmFzZWQgb24gYSBoZWlnaHRNYXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXl9IGhlaWdodE1hcCB0aGUgaGVpZ2h0bWFwXG4gICAgICAgICAqIEBwYXJhbSAge1RIUkVFLkdlb21ldHJ5fSBnZW9tZXRyeSAgdGhlIGdlb21ldHJ5IHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9WZXJ0ZXhDb2xvciA9IGZ1bmN0aW9uKGhlaWdodE1hcCwgZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIC8vIGdldCBoZWlnaHRNYXAgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0TWFwLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGRlcHRoID0gaGVpZ2h0TWFwWzBdLmxlbmd0aFxuICAgICAgICAgICAgLy8gbG9vcCBvbiBlYWNoIHZlcnRleCBvZiB0aGUgZ2VvbWV0cnlcbiAgICAgICAgICAgIHZhciBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1tpXVxuICAgICAgICAgICAgICAgIGlmIChmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0KVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5hKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5iKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5jKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycy5wdXNoKHZlcnRleElkeFRvQ29sb3IoZmFjZS5kKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMylcbiAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCh2ZXJ0ZXhJZHhUb0NvbG9yKGZhY2UuYSkuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCh2ZXJ0ZXhJZHhUb0NvbG9yKGZhY2UuYikuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCh2ZXJ0ZXhJZHhUb0NvbG9yKGZhY2UuYykuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgY29uc29sZS5hc3NlcnQoZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZlcnRleElkeFRvQ29sb3IodmVydGV4SWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHZlcnRleElkeCAlIHdpZHRoKVxuICAgICAgICAgICAgICAgIHZhciB6ID0gTWF0aC5mbG9vcih2ZXJ0ZXhJZHggLyB3aWR0aClcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0TWFwW3hdW3pdXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRIUkVFeC5UZXJyYWluLmhlaWdodFRvQ29sb3IoaGVpZ2h0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdpdmUgYSBjb2xvciBiYXNlZCBvbiBhIGdpdmVuIGhlaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHRcbiAgICAgICAgICogQHJldHVybiB7VEhSRUUuQ29sb3J9IHRoZSBjb2xvciBmb3IgdGhpcyBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLmhlaWdodFRvQ29sb3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgY29sb3IgYmFzZWQgb24gaGVpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0ICogMikgKiAwLjUgKyAwLjJcbiAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0UkdCKDAsIDAsIGhlaWdodClcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDAuNykge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IC0gMC41KSAvIDAuMlxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiAwLjUgKyAwLjJcbiAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0UkdCKDAsIGhlaWdodCwgMClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IC0gMC43KSAvIDAuM1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiAwLjUgKyAwLjVcbiAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0UkdCKGhlaWdodCwgaGVpZ2h0LCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbG9yLnNldFJHQigxLDEsMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcblxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy9cdFx0Y29tbWVudFx0XHRcdFx0XHRcdFx0XHQvL1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBsYW5lIGdlb21ldHJ5IHdpdGggVEhSRUUuRmFjZTMgZnJvbSB0aHJlZS5qcyByNjZcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IHdpZHRoICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IGhlaWdodCAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IHdpZHRoU2VnbWVudHMgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHBhcmFtIHtbdHlwZV19IGhlaWdodFNlZ21lbnRzIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIFRIUkVFeC5UZXJyYWluLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cykge1xuXG4gICAgICAgICAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cbiAgICAgICAgICAgIHZhciBpeCwgaXo7XG4gICAgICAgICAgICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIHZhciBncmlkWCA9IHRoaXMud2lkdGhTZWdtZW50cztcbiAgICAgICAgICAgIHZhciBncmlkWiA9IHRoaXMuaGVpZ2h0U2VnbWVudHM7XG5cbiAgICAgICAgICAgIHZhciBncmlkWDEgPSBncmlkWCArIDE7XG4gICAgICAgICAgICB2YXIgZ3JpZFoxID0gZ3JpZFogKyAxO1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudF93aWR0aCA9IHRoaXMud2lkdGggLyBncmlkWDtcbiAgICAgICAgICAgIHZhciBzZWdtZW50X2hlaWdodCA9IHRoaXMuaGVpZ2h0IC8gZ3JpZFo7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcblxuICAgICAgICAgICAgZm9yIChpeiA9IDA7IGl6IDwgZ3JpZFoxOyBpeisrKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KyspIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaXogKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyh4LCAteSwgMCkpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaXogPSAwOyBpeiA8IGdyaWRaOyBpeisrKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXggKyBncmlkWDEgKiBpejtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqIChpeiArIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IChpeCArIDEpICsgZ3JpZFgxICogKGl6ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gKGl4ICsgMSkgKyBncmlkWDEgKiBpejtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoaXggLyBncmlkWCwgMSAtIGl6IC8gZ3JpZFopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoaXggLyBncmlkWCwgMSAtIChpeiArIDEpIC8gZ3JpZFopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoKGl4ICsgMSkgLyBncmlkWCwgMSAtIChpeiArIDEpIC8gZ3JpZFopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoKGl4ICsgMSkgLyBncmlkWCwgMSAtIGl6IC8gZ3JpZFopO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKGEsIGIsIGQpO1xuICAgICAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChmYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3V2YSwgdXZiLCB1dmRdKTtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKGIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChmYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3V2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpXSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBUSFJFRXguVGVycmFpbi5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtcblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgICBjYW52YXM6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY2FudmFzM1wiKVxuICAgICAgICB9KTtcbiAgICAgICAgLyogRnVsbHNjcmVlbiAqL1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICAvKiBBcHBlbmQgdG8gSFRNTCAqL1xuICAgICAgICB2YXIgb25SZW5kZXJGY3RzID0gW107XG4gICAgICAgIHZhciBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICB2YXIgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDI1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4wMSwgMTAwMCk7XG4gICAgICAgIC8qIFBsYXkgYXJvdW5kIHdpdGggY2FtZXJhIHBvc2l0aW9uaW5nICovXG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMTU7XG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ID0gMjtcbiAgICAgICAgLyogRm9nIHByb3ZpZGVzIGRlcHRoIHRvIHRoZSBsYW5kc2NhcGUqL1xuICAgICAgICBzY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKDB4MDAwLCAwLCA0NSk7XG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHgyMDIwMjApXG4gICAgICAgICAgICBzY2VuZS5hZGQobGlnaHQpXG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgnd2hpdGUnLCA1KVxuICAgICAgICAgICAgbGlnaHQucG9zaXRpb24uc2V0KDAuNSwgMC4wLCAyKVxuICAgICAgICAgICAgc2NlbmUuYWRkKGxpZ2h0KVxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoJ3doaXRlJywgMC43NSAqIDIpXG4gICAgICAgICAgICBsaWdodC5wb3NpdGlvbi5zZXQoLTAuNSwgLTAuNSwgLTIpXG4gICAgICAgICAgICBzY2VuZS5hZGQobGlnaHQpXG4gICAgICAgIH0pKClcbiAgICAgICAgdmFyIGhlaWdodE1hcCA9IFRIUkVFeC5UZXJyYWluLmFsbG9jYXRlSGVpZ2h0TWFwKDI1NiwgMjU2KVxuICAgICAgICBUSFJFRXguVGVycmFpbi5zaW1wbGV4SGVpZ2h0TWFwKGhlaWdodE1hcClcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9QbGFuZUdlb21ldHJ5KGhlaWdodE1hcClcbiAgICAgICAgVEhSRUV4LlRlcnJhaW4uaGVpZ2h0TWFwVG9WZXJ0ZXhDb2xvcihoZWlnaHRNYXAsIGdlb21ldHJ5KVxuICAgICAgICAvKiBXaXJlZnJhbWUgYnVpbHQtaW4gY29sb3IgaXMgd2hpdGUsIG5vIG5lZWQgdG8gY2hhbmdlIHRoYXQgKi9cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgc2NlbmUuYWRkKG1lc2gpO1xuICAgICAgICBtZXNoLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSk7XG4gICAgICAgIC8qIFBsYXkgYXJvdW5kIHdpdGggdGhlIHNjYWxpbmcgKi9cbiAgICAgICAgbWVzaC5zY2FsZS55ID0gMy41O1xuICAgICAgICBtZXNoLnNjYWxlLnggPSAzO1xuICAgICAgICBtZXNoLnNjYWxlLnogPSAwLjIwO1xuICAgICAgICBtZXNoLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEwKTtcbiAgICAgICAgLyogUGxheSBhcm91bmQgd2l0aCB0aGUgY2FtZXJhICovXG4gICAgICAgIG9uUmVuZGVyRmN0cy5wdXNoKGZ1bmN0aW9uKGRlbHRhLCBub3cpIHtcbiAgICAgICAgICAgIG1lc2gucm90YXRpb24ueiArPSAwLjAyNSAqIGRlbHRhO1xuICAgICAgICB9KVxuICAgICAgICBvblJlbmRlckZjdHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgICAgfSlcbiAgICAgICAgdmFyIGxhc3RUaW1lTXNlYyA9IG51bGxcbiAgICAgICAgd2luZG93LmFuaW1GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRlKG5vd01zZWMpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgICAgIGxhc3RUaW1lTXNlYyA9IGxhc3RUaW1lTXNlYyB8fCBub3dNc2VjIC0gMTAwMCAvIDYwXG4gICAgICAgICAgICB2YXIgZGVsdGFNc2VjID0gTWF0aC5taW4oMjAwLCBub3dNc2VjIC0gbGFzdFRpbWVNc2VjKVxuICAgICAgICAgICAgbGFzdFRpbWVNc2VjID0gbm93TXNlY1xuICAgICAgICAgICAgb25SZW5kZXJGY3RzLmZvckVhY2goZnVuY3Rpb24ob25SZW5kZXJGY3QpIHtcbiAgICAgICAgICAgICAgICBvblJlbmRlckZjdChkZWx0YU1zZWMgLyAxMDAwLCBub3dNc2VjIC8gMTAwMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBmcm9udGVuZC9jb21wb25lbnRzL3BsYXkvTGFuZHNjYXBlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7OztBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUdBOzs7O0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

})